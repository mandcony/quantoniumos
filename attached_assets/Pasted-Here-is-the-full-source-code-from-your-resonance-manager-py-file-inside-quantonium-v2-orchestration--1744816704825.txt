Here is the full source code from your resonance_manager.py file inside quantonium_v2/orchestration/. This file powers the live symbolic process tracker and resonance state provider used by q_wave_debugger.py and others:

python
Copy
Edit
# File: C:\\quantonium_v2\\orchestration\\resonance_manager.py
# Purpose: Live symbolic process tracker and resonance state provider

import time
import numpy as np
from encryption.resonance_encrypt import resonance_encrypt, resonance_decrypt
from encryption.geometric_waveform_hash import geometric_waveform_hash_from_text
from encryption.entropy_qrng import generate_symbolic_qrng_sequence

# -----------------------------------------------------------------------------
# Internal mock state tracker (replace with live container tracker later)
# -----------------------------------------------------------------------------
_symbolic_state = {
    "label": "container_alpha",
    "payload": "ResonantSymbolicPayload",
    "amplitude": 1.870,
    "phase": 0.950,
    "container_count": 1,
    "sealed": None,
    "timestamp": None
}

# -----------------------------------------------------------------------------
# Single container state generator (simulated)
# -----------------------------------------------------------------------------
def get_active_resonance_state():
    A, phi = _symbolic_state['amplitude'], _symbolic_state['phase']
    payload = _symbolic_state['payload']
    sealed = resonance_encrypt(payload, A, phi)

    _symbolic_state.update({
        "sealed": sealed.hex(),
        "timestamp": time.time()
    })

    return {
        "label": _symbolic_state["label"],
        "amplitude": A,
        "phase": phi,
        "vector": np.array([A * np.cos(phi + i) for i in range(64)]),
        "container_count": _symbolic_state["container_count"]
    }

# -----------------------------------------------------------------------------
# Multi-container interface used by q_wave_debugger.py
# -----------------------------------------------------------------------------
def get_all_resonance_containers():
    # Currently simulates 3 symbolic containers with phased offsets
    base = get_active_resonance_state()
    containers = []

    for i in range(3):
        containers.append({
            "label": f"{base['label']}_{i}",
            "amplitude": base["amplitude"] + (i * 0.25),
            "phase": base["phase"] + (i * 0.5),
            "vector": np.array([base["amplitude"] * np.cos(base["phase"] + i + t) for t in range(64)]),
            "container_count": i + 1
        })

    return containers

# -----------------------------------------------------------------------------
# Manual Test Hook
# -----------------------------------------------------------------------------
if __name__ == "__main__":
    containers = get_all_resonance_containers()
    for c in containers:
        print(f"ðŸ§  Container {c['label']} â†’ A: {c['amplitude']}, Ï†: {c['phase']}")