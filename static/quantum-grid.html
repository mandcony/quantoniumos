<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
        }
        
        /* Hide header when embedded in the OS interface */
        body.embedded header {
            display: none;
        }
        
        header {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #222;
        }
        
        .logo {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 1px;
            color: #fff;
        }
        
        .subtitle {
            font-size: 14px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px;
        }
        
        .panel {
            background-color: #111;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .panel h2 {
            margin-top: 0;
            font-weight: 300;
            font-size: 18px;
            margin-bottom: 20px;
            border-bottom: 1px solid #222;
            padding-bottom: 10px;
        }
        
        .panel p {
            color: #aaa;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .quantum-grid-container {
            margin-top: 20px;
            margin-bottom: 20px;
            height: 600px;
            background-color: #0a0a0a;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .quantum-grid {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        
        .matrix-visualization {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 30, 60, 0.2);
        }
        
        .quantum-cell {
            background-color: rgba(0, 183, 255, 0.05);
            border: 1px solid rgba(0, 183, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .quantum-cell:hover {
            background-color: rgba(0, 183, 255, 0.2);
        }
        
        .quantum-cell.active {
            background-color: rgba(0, 183, 255, 0.3);
        }
        
        .control-panel {
            background-color: #0a0a0a;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .control-group {
            margin-bottom: 15px;
            flex: 1;
            min-width: 200px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            background: #333;
            height: 5px;
            -webkit-appearance: none;
            outline: none;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #00b7ff;
            border-radius: 50%;
        }
        
        .control-group input[type="number"] {
            width: 70px;
            padding: 5px 8px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 3px;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 3px;
        }
        
        .slider-value {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            background-color: #00475e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #00b7ff;
        }
        
        button.active {
            background-color: #00b7ff;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .overlay-content {
            background: #111;
            padding: 20px;
            border-radius: 5px;
            max-width: 500px;
            text-align: center;
        }
        
        .overlay-content h3 {
            margin-top: 0;
            color: #00b7ff;
        }
        
        .state-display {
            font-family: monospace;
            background-color: #0a0a0a;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .info-panel {
            background-color: rgba(0, 183, 255, 0.1);
            border-left: 3px solid #00b7ff;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .info-panel h3 {
            margin-top: 0;
            font-size: 16px;
            color: #00b7ff;
        }
        
        /* Wave animation on grid */
        @keyframes wave {
            0% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
            100% {
                transform: translateY(0);
            }
        }
        
        .connection-line {
            position: absolute;
            background-color: rgba(0, 183, 255, 0.7);
            height: 2px;
            transform-origin: 0 0;
            z-index: 5;
            transition: opacity 0.3s;
        }
        
        .qubit-node {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #00b7ff;
            border-radius: 50%;
            z-index: 6;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px rgba(0, 183, 255, 0.8);
        }
        
        .qubit-node.entangled {
            background-color: #b967ff;
            box-shadow: 0 0 8px rgba(185, 103, 255, 0.8);
        }
        
        .probability-wave {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(0, 183, 255, 0.4);
            transform: translate(-50%, -50%);
            animation: wave-expand 2s infinite;
        }
        
        @keyframes wave-expand {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }

        /* Gate visualization */
        .gate-tooltip {
            position: absolute;
            background-color: #000;
            color: #fff;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 10;
            pointer-events: none;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        /* Detailed Qubit View Styles */
        .qubit-detail-panel {
            margin-top: 20px;
            position: relative;
        }
        
        .qubit-display-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-button {
            min-width: 160px;
        }
        
        .detail-control {
            padding: 8px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 3px;
        }
        
        .detail-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .detail-selector input {
            width: 70px;
        }
        
        .qubit-detail-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-around;
            padding: 20px 0;
            max-height: 600px;
            overflow-y: auto;
            display: none;
        }
        
        .qubit-detail-container.active {
            display: flex;
        }
        
        .qubit-card {
            width: 200px;
            background: rgba(10, 10, 15, 0.8);
            border: 1px solid rgba(0, 183, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .qubit-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 183, 255, 0.2);
            padding-bottom: 8px;
        }
        
        .qubit-index {
            font-weight: bold;
            font-size: 16px;
            color: #00b7ff;
        }
        
        .state-probabilities {
            margin-bottom: 15px;
        }
        
        .state-bar {
            height: 20px;
            margin: 5px 0;
            border-radius: 3px;
            background: #090909;
            position: relative;
            overflow: hidden;
        }
        
        .state-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00475e 0%, #00b7ff 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .state-label {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            font-size: 12px;
            color: white;
            mix-blend-mode: difference;
        }
        
        .state-value {
            position: absolute;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            font-size: 12px;
            color: white;
            mix-blend-mode: difference;
        }
        
        .phase-info {
            margin-bottom: 15px;
        }
        
        .phase-indicator {
            width: 100%;
            height: 8px;
            background: #090909;
            border-radius: 4px;
            position: relative;
            margin-top: 5px;
        }
        
        .phase-marker {
            position: absolute;
            top: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00b7ff;
            transform: translateX(-50%);
            left: 0%;
            transition: left 0.3s ease;
            box-shadow: 0 0 5px rgba(0, 183, 255, 0.7);
        }
        
        .bloch-sphere {
            width: 120px;
            height: 120px;
            margin: 0 auto;
            position: relative;
            border-radius: 50%;
            background: radial-gradient(circle at center, #000 0%, #001a29 100%);
            border: 1px solid rgba(0, 183, 255, 0.3);
            overflow: hidden;
        }
        
        .bloch-sphere::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 1px;
            background: rgba(0, 183, 255, 0.3);
            transform-origin: center;
        }
        
        .bloch-sphere::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1px;
            height: 100%;
            background: rgba(0, 183, 255, 0.3);
            transform-origin: center;
        }
        
        .qubit-vector {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 0%;
            background: #00b7ff;
            transform-origin: bottom center;
            transform: rotate(0deg);
            box-shadow: 0 0 5px rgba(0, 183, 255, 0.7);
            z-index: 2;
        }
        
        .qubit-vector::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 6px solid #00b7ff;
            margin-top: -6px;
        }
    </style>
    <script src="/static/quantum-matrix.js"></script>
    <script src="/static/circuit-designer.js"></script>
</head>
<body>
    <header>
        <div class="logo">QUANTONIUMOS</div>
        <div class="subtitle">ADVANCED QUANTUM CRYPTOGRAPHY SYSTEM</div>
    </header>
    
    <div class="container">
        <div class="panel">
            <h2>Quantum Grid (512-Qubit Simulator)</h2>
            <p>
                This quantum circuit simulator allows you to visualize and interact with up to 512 qubits.
                Use the controls below to adjust qubit count, entanglement, and gate operations.
                The visualization uses matrix eigenvector calculations for high-dimensional quantum states.
            </p>
            
            <div class="info-panel">
                <h3>System Status</h3>
                <p>Using quantum-inspired symbolic matrix mathematics for operations. 
                   All results are deterministic based on internal quantum simulation.</p>
            </div>
            
            <!-- Circuit Designer Container -->
            <div id="circuit-designer-container"></div>
            

            
            <div class="control-panel">
                <div class="control-group">
                    <label for="qubit-count">Qubit Count:</label>
                    <input type="range" id="qubit-count" min="2" max="512" value="64">
                    <div class="slider-value">
                        <span>2</span>
                        <span id="qubit-count-value">64</span>
                        <span>512</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="entanglement">Entanglement Strength:</label>
                    <input type="range" id="entanglement" min="0" max="1" step="0.1" value="0.5">
                    <div class="slider-value">
                        <span>0.0</span>
                        <span id="entanglement-value">0.5</span>
                        <span>1.0</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="gate-type">Gate Type:</label>
                    <select id="gate-type">
                        <option value="h">Hadamard (H)</option>
                        <option value="x">Pauli-X</option>
                        <option value="y">Pauli-Y</option>
                        <option value="z">Pauli-Z</option>
                        <option value="cx">CNOT</option>
                        <option value="cz">CZ</option>
                        <option value="swap">SWAP</option>
                        <option value="t">T Gate</option>
                        <option value="s">S Gate</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="target-qubit">Target Qubit:</label>
                    <input type="number" id="target-qubit" min="0" max="511" value="0">
                </div>
                
                <div class="control-group">
                    <label for="control-qubit">Control Qubit (for 2-qubit gates):</label>
                    <input type="number" id="control-qubit" min="0" max="511" value="1">
                </div>
            </div>
            
            <div class="button-group">
                <button id="apply-gate">Apply Gate</button>
                <button id="reset-state">Reset State</button>
                <button id="toggle-animation">Toggle Animation</button>
                <button id="run-circuit">Run Complete Circuit</button>
            </div>
            
            <div class="quantum-grid-container">
                <div id="quantum-grid" class="quantum-grid">
                    <canvas id="matrix-visualization" class="matrix-visualization"></canvas>
                </div>
                <div class="controls-overlay">
                    <div class="zoom-controls">
                        <button id="zoom-in">+</button>
                        <button id="zoom-out">−</button>
                        <button id="reset-view">Reset View</button>
                    </div>
                    <div class="view-toggle">
                        <select id="visualization-mode">
                            <option value="matrix">Matrix View</option>
                            <option value="network">Network View</option>
                            <option value="bloch">Bloch Sphere</option>
                            <option value="heatmap">Density Heatmap</option>
                        </select>
                    </div>
                </div>
                <div id="overlay" class="overlay">
                    <div class="overlay-content">
                        <h3>Quantum Computation Complete</h3>
                        <p>The quantum circuit has been executed successfully.</p>
                        <div id="computation-result" class="state-display"></div>
                        <button id="close-overlay">Close</button>
                    </div>
                </div>
            </div>
            
            <div class="state-display" id="state-display">// Quantum state will appear here</div>
        </div>
    </div>
    
    <script>
        // Check if page is embedded in the OS interface
        function checkEmbedded() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('embedded') === 'true') {
                document.body.classList.add('embedded');
            }
        }
        
        // Run on page load
        window.addEventListener('DOMContentLoaded', checkEmbedded);
        // DOM elements
        const qubitCountSlider = document.getElementById('qubit-count');
        const entanglementSlider = document.getElementById('entanglement');
        const gateTypeSelect = document.getElementById('gate-type');
        const targetQubitInput = document.getElementById('target-qubit');
        const controlQubitInput = document.getElementById('control-qubit');
        const qubitCountValue = document.getElementById('qubit-count-value');
        const entanglementValue = document.getElementById('entanglement-value');
        const applyGateButton = document.getElementById('apply-gate');
        const resetStateButton = document.getElementById('reset-state');
        const toggleAnimationButton = document.getElementById('toggle-animation');
        const runCircuitButton = document.getElementById('run-circuit');
        const quantumGrid = document.getElementById('quantum-grid');
        const stateDisplay = document.getElementById('state-display');
        const overlay = document.getElementById('overlay');
        const computationResult = document.getElementById('computation-result');
        const closeOverlayButton = document.getElementById('close-overlay');
        

        // State variables
        let qubitCount = 64;
        let entanglementStrength = 0.5;
        let gateHistory = [];
        let cells = [];
        let nodes = [];
        let connections = [];
        let animationActive = true;
        let highlightedCells = new Set();
        let canvas;
        let ctx;
        let visualizationMode = 'matrix';
        let viewportX = 0;
        let viewportY = 0;
        let zoomLevel = 1;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let eigenvalues = [];
        let eigenvectors = [];
        
        // Update value displays
        qubitCountSlider.addEventListener('input', () => {
            qubitCount = parseInt(qubitCountSlider.value);
            qubitCountValue.textContent = qubitCount;
            
            // Update max values for control and target inputs
            targetQubitInput.max = qubitCount - 1;
            controlQubitInput.max = qubitCount - 1;
            
            // Ensure current values don't exceed new max
            if (parseInt(targetQubitInput.value) >= qubitCount) {
                targetQubitInput.value = qubitCount - 1;
            }
            if (parseInt(controlQubitInput.value) >= qubitCount) {
                controlQubitInput.value = qubitCount - 1;
            }
            

            
            // Generate new eigenvalues and eigenvectors for visualization
            generateQuantumState();
            updateQuantumGrid();
            updateStateDisplay();
        });
        
        // Initialize canvas and context
        function initCanvas() {
            canvas = document.getElementById('matrix-visualization');
            ctx = canvas.getContext('2d');
            
            // Set canvas dimensions to match its container
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Add event listeners for canvas interaction
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('wheel', handleCanvasWheel);
            
            // Initialize visualization mode
            const vizModeSelect = document.getElementById('visualization-mode');
            vizModeSelect.addEventListener('change', function() {
                visualizationMode = this.value;
                drawVisualization();
            });
            
            // Initialize zoom controls
            document.getElementById('zoom-in').addEventListener('click', function() {
                zoomLevel *= 1.2;
                drawVisualization();
            });
            
            document.getElementById('zoom-out').addEventListener('click', function() {
                zoomLevel /= 1.2;
                drawVisualization();
            });
            
            document.getElementById('reset-view').addEventListener('click', function() {
                zoomLevel = 1;
                viewportX = 0;
                viewportY = 0;
                drawVisualization();
            });
        }
        
        // Generate quantum state with eigenvalues and eigenvectors
        function generateQuantumState() {
            // Generate eigenvalues for the quantum state (512 max)
            eigenvalues = [];
            eigenvectors = [];
            
            // Create pseudo-eigenvalues for visualization
            for (let i = 0; i < qubitCount; i++) {
                // Random complex eigenvalue
                eigenvalues.push({
                    real: Math.random() * 2 - 1,
                    imag: Math.random() * 2 - 1
                });
                
                // Create eigenvector for each eigenvalue
                const eigenvector = [];
                for (let j = 0; j < qubitCount; j++) {
                    eigenvector.push({
                        real: Math.random() * 2 - 1,
                        imag: Math.random() * 2 - 1
                    });
                }
                eigenvectors.push(eigenvector);
            }
        }
        
        entanglementSlider.addEventListener('input', () => {
            entanglementStrength = parseFloat(entanglementSlider.value);
            entanglementValue.textContent = entanglementStrength.toFixed(1);
            updateConnections();
        });
        
        // Apply gate button
        applyGateButton.addEventListener('click', () => {
            const gateType = gateTypeSelect.value;
            const targetQubit = parseInt(targetQubitInput.value);
            const controlQubit = parseInt(controlQubitInput.value);
            
            // Validate inputs
            if (targetQubit >= qubitCount || targetQubit < 0) {
                alert(`Target qubit must be between 0 and ${qubitCount - 1}`);
                return;
            }
            
            if (['cx', 'cz', 'swap'].includes(gateType)) {
                if (controlQubit >= qubitCount || controlQubit < 0) {
                    alert(`Control qubit must be between 0 and ${qubitCount - 1}`);
                    return;
                }
                
                if (controlQubit === targetQubit) {
                    alert("Control and target qubits must be different");
                    return;
                }
            }
            
            // Add gate to history
            gateHistory.push({
                type: gateType,
                target: targetQubit,
                control: ['cx', 'cz', 'swap'].includes(gateType) ? controlQubit : null
            });
            
            // Visualize gate application
            visualizeGateApplication(gateType, targetQubit, controlQubit);
            
            // Update state display
            updateStateDisplay();
        });
        
        // Reset state button
        resetStateButton.addEventListener('click', () => {
            gateHistory = [];
            updateStateDisplay();
            clearHighlights();
        });
        
        // Toggle animation button
        toggleAnimationButton.addEventListener('click', () => {
            animationActive = !animationActive;
            toggleAnimationButton.textContent = animationActive ? 'Pause Animation' : 'Resume Animation';
            toggleAnimationButton.classList.toggle('active', animationActive);
        });
        
        // Run complete circuit button
        runCircuitButton.addEventListener('click', () => {
            if (gateHistory.length === 0) {
                alert("Please apply at least one gate before running the circuit");
                return;
            }
            
            // Show overlay with loading animation
            overlay.classList.add('active');
            
            // Simulate computation delay
            setTimeout(() => {
                // Generate a simplified result based on the circuit
                const result = generateCircuitResult();
                computationResult.textContent = result;
            }, 1500);
        });
        
        // Close overlay button
        closeOverlayButton.addEventListener('click', () => {
            overlay.classList.remove('active');
        });
        
        // Initialize quantum grid
        function initQuantumGrid() {
            // Clear existing grid
            quantumGrid.innerHTML = '';
            cells = [];
            nodes = [];
            connections = [];
            
            // Calculate grid dimensions based on qubit count
            const gridSize = Math.ceil(Math.sqrt(qubitCount));
            const columns = gridSize;
            const rows = Math.ceil(qubitCount / columns);
            
            // Update grid CSS
            quantumGrid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            quantumGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // Create cells
            for (let i = 0; i < qubitCount; i++) {
                const cell = document.createElement('div');
                cell.className = 'quantum-cell';
                cell.setAttribute('data-index', i);
                quantumGrid.appendChild(cell);
                cells.push(cell);
                
                // Add qubit node
                const node = document.createElement('div');
                node.className = 'qubit-node';
                node.setAttribute('data-index', i);
                
                // Position node within cell
                const rect = cell.getBoundingClientRect();
                const gridRect = quantumGrid.getBoundingClientRect();
                const x = (rect.left - gridRect.left) + rect.width / 2;
                const y = (rect.top - gridRect.top) + rect.height / 2;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                quantumGrid.appendChild(node);
                nodes.push(node);
                
                // Add probability wave
                if (animationActive) {
                    const wave = document.createElement('div');
                    wave.className = 'probability-wave';
                    wave.style.left = `${x}px`;
                    wave.style.top = `${y}px`;
                    wave.style.animationDelay = `${Math.random() * 2}s`;
                    quantumGrid.appendChild(wave);
                }
            }
            
            // Create initial connections
            updateConnections();
        }
        
        // Update connections between qubits
        function updateConnections() {
            // Remove existing connections
            connections.forEach(conn => conn.remove());
            connections = [];
            
            // Create new connections based on entanglement strength
            const gridRect = quantumGrid.getBoundingClientRect();
            
            for (let i = 0; i < nodes.length; i++) {
                const node1 = nodes[i];
                const node1Rect = node1.getBoundingClientRect();
                
                // Calculate number of connections based on entanglement strength
                const connectionCount = Math.floor(entanglementStrength * 3) + 1;
                
                // Connect to nearest nodes
                for (let j = 0; j < connectionCount; j++) {
                    // Find a node to connect to (excluding self)
                    let node2Index;
                    
                    // For structured connections
                    if (j === 0 && i < nodes.length - 1) {
                        // Connect to next node
                        node2Index = i + 1;
                    } else if (j === 1 && i + Math.sqrt(nodes.length) < nodes.length) {
                        // Connect to node below (if exists)
                        node2Index = i + Math.floor(Math.sqrt(nodes.length));
                    } else {
                        // Connect to a random node
                        do {
                            node2Index = Math.floor(Math.random() * nodes.length);
                        } while (node2Index === i);
                    }
                    
                    if (node2Index >= nodes.length) continue;
                    
                    const node2 = nodes[node2Index];
                    const node2Rect = node2.getBoundingClientRect();
                    
                    // Calculate positions
                    const x1 = node1Rect.left - gridRect.left + node1Rect.width / 2;
                    const y1 = node1Rect.top - gridRect.top + node1Rect.height / 2;
                    const x2 = node2Rect.left - gridRect.left + node2Rect.width / 2;
                    const y2 = node2Rect.top - gridRect.top + node2Rect.height / 2;
                    
                    // Calculate length and angle
                    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                    
                    // Create connection line
                    const line = document.createElement('div');
                    line.className = 'connection-line';
                    line.style.width = `${length}px`;
                    line.style.left = `${x1}px`;
                    line.style.top = `${y1}px`;
                    line.style.transform = `rotate(${angle}deg)`;
                    
                    // Only show if entanglement strength is above 0
                    line.style.opacity = entanglementStrength > 0 ? 
                        (0.3 + entanglementStrength * 0.7) : 0;
                    
                    quantumGrid.appendChild(line);
                    connections.push(line);
                }
            }
        }
        
        // Visualize gate application
        function visualizeGateApplication(gateType, targetQubit, controlQubit) {
            // Clear previous highlights
            clearHighlights();
            
            // Highlight target qubit
            if (targetQubit < cells.length) {
                cells[targetQubit].classList.add('active');
                highlightedCells.add(targetQubit);
            }
            
            // For 2-qubit gates, highlight control qubit
            if (['cx', 'cz', 'swap'].includes(gateType) && controlQubit < cells.length) {
                cells[controlQubit].classList.add('active');
                highlightedCells.add(controlQubit);
                
                // Add entanglement visualization
                nodes[targetQubit].classList.add('entangled');
                nodes[controlQubit].classList.add('entangled');
                
                // Create temporary connection if one doesn't exist
                const gridRect = quantumGrid.getBoundingClientRect();
                const node1Rect = nodes[targetQubit].getBoundingClientRect();
                const node2Rect = nodes[controlQubit].getBoundingClientRect();
                
                const x1 = node1Rect.left - gridRect.left + node1Rect.width / 2;
                const y1 = node1Rect.top - gridRect.top + node1Rect.height / 2;
                const x2 = node2Rect.left - gridRect.left + node2Rect.width / 2;
                const y2 = node2Rect.top - gridRect.top + node2Rect.height / 2;
                
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                const line = document.createElement('div');
                line.className = 'connection-line';
                line.style.width = `${length}px`;
                line.style.left = `${x1}px`;
                line.style.top = `${y1}px`;
                line.style.transform = `rotate(${angle}deg)`;
                line.style.backgroundColor = 'rgba(185, 103, 255, 0.7)';
                line.style.boxShadow = '0 0 8px rgba(185, 103, 255, 0.5)';
                line.style.zIndex = 7;
                
                quantumGrid.appendChild(line);
                connections.push(line);
                
                // Create gate visualization tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'gate-tooltip';
                tooltip.textContent = gateTypeToLabel(gateType);
                tooltip.style.left = `${(x1 + x2) / 2}px`;
                tooltip.style.top = `${(y1 + y2) / 2}px`;
                tooltip.style.opacity = 1;
                
                quantumGrid.appendChild(tooltip);
                
                // Remove gate visualization after a delay
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                    setTimeout(() => tooltip.remove(), 300);
                }, 2000);
            } else {
                // Single qubit gate - create gate tooltip
                const nodeRect = nodes[targetQubit].getBoundingClientRect();
                const gridRect = quantumGrid.getBoundingClientRect();
                const x = nodeRect.left - gridRect.left + nodeRect.width / 2;
                const y = nodeRect.top - gridRect.top + nodeRect.height / 2;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'gate-tooltip';
                tooltip.textContent = gateTypeToLabel(gateType);
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
                tooltip.style.opacity = 1;
                
                quantumGrid.appendChild(tooltip);
                
                // Remove gate visualization after a delay
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                    setTimeout(() => tooltip.remove(), 300);
                }, 2000);
            }
            
            // Remove highlights after a delay
            setTimeout(() => {
                clearHighlights();
            }, 2500);
        }
        
        // Clear highlights
        function clearHighlights() {
            highlightedCells.forEach(index => {
                if (index < cells.length) {
                    cells[index].classList.remove('active');
                }
            });
            
            nodes.forEach(node => {
                node.classList.remove('entangled');
            });
            
            highlightedCells.clear();
        }
        
        // Convert gate type to human-readable label
        function gateTypeToLabel(gateType) {
            const labels = {
                'h': 'H',
                'x': 'X',
                'y': 'Y',
                'z': 'Z',
                'cx': 'CNOT',
                'cz': 'CZ',
                'swap': 'SWAP',
                't': 'T',
                's': 'S'
            };
            
            return labels[gateType] || gateType.toUpperCase();
        }
        
        // Update quantum grid
        function updateQuantumGrid() {
            initQuantumGrid();
        }
        
        // Update state display
        function updateStateDisplay() {
            // Generate a simplified state representation based on the circuit
            let stateText = '// Quantum State';
            
            if (gateHistory.length === 0) {
                stateText += '\nInitial state: |';
                for (let i = 0; i < qubitCount; i++) {
                    stateText += '0';
                }
                stateText += '⟩';
                
                // Add formula notation for initial state
                stateText += '\n\nQuantum Formula: |0⟩^{⊗' + qubitCount + '}';
            } else {
                stateText += '\nCircuit:';
                
                gateHistory.forEach((gate, index) => {
                    stateText += `\n${index + 1}. ${gateTypeToLabel(gate.type)} gate`;
                    
                    if (gate.control !== null) {
                        stateText += ` with control=${gate.control}, target=${gate.target}`;
                    } else {
                        stateText += ` on qubit ${gate.target}`;
                    }
                });
                
                // Show a simplified final state
                stateText += '\n\nFinal state: Complex superposition of ';
                
                // Calculate a simplified count of basis states in the superposition
                // This is a visual approximation for the UI only
                const basisStates = Math.min(Math.pow(2, Math.min(gateHistory.length + 1, 10)), Math.pow(2, qubitCount));
                stateText += `${basisStates} basis states`;
                
                // Add simplified quantum formula notation
                stateText += '\n\nQuantum Formula: ';
                
                // Create a simple gate sequence notation
                const hadamardGates = gateHistory.filter(gate => gate.type === 'h');
                const cnotGates = gateHistory.filter(gate => gate.type === 'cx');
                
                if (hadamardGates.length === 0 && cnotGates.length === 0) {
                    // Just basic gates without superposition or entanglement
                    stateText += `U|0⟩^{⊗${qubitCount}}`;
                } else if (hadamardGates.length > 0 && cnotGates.length === 0) {
                    // Superposition but no entanglement
                    const hTargets = [...new Set(hadamardGates.map(g => g.target))].sort((a, b) => a - b);
                    
                    if (hTargets.length === qubitCount) {
                        // All qubits in superposition
                        stateText += `H^{⊗${qubitCount}}|0⟩^{⊗${qubitCount}} = \\frac{1}{\\sqrt{2^${qubitCount}}}\\sum_{i=0}^{2^${qubitCount}-1}|i⟩`;
                    } else {
                        // Some qubits in superposition
                        stateText += `H_{${hTargets.join(',')}}|0⟩^{⊗${qubitCount}}`;
                    }
                } else if (cnotGates.length > 0) {
                    // Entanglement present
                    if (hadamardGates.length === 1 && cnotGates.length === 1 && 
                        hadamardGates[0].target === cnotGates[0].control) {
                        // Typical Bell state preparation
                        const control = cnotGates[0].control;
                        const target = cnotGates[0].target;
                        stateText += `CNOT_{${control},${target}}H_{${control}}|0⟩^{⊗${qubitCount}} = \\frac{1}{\\sqrt{2}}(|0_{${control}}0_{${target}}⟩ + |1_{${control}}1_{${target}}⟩) ⊗ |0⟩^{⊗${qubitCount-2}}`;
                    } else {
                        // General entangled state
                        stateText += `U|0⟩^{⊗${qubitCount}} (see full formula after running circuit)`;
                    }
                }
            }
            
            stateDisplay.textContent = stateText;
        }
        
        // Generate a simulated result for the quantum circuit
        function generateCircuitResult() {
            const gateCount = gateHistory.length;
            const hadamardCount = gateHistory.filter(gate => gate.type === 'h').length;
            const cnotCount = gateHistory.filter(gate => gate.type === 'cx').length;
            
            let result = '// Quantum Circuit Execution Results\n';
            result += `Circuit depth: ${gateCount}\n`;
            result += `Qubit count: ${qubitCount}\n`;
            result += `Hadamard gates: ${hadamardCount}\n`;
            result += `CNOT gates: ${cnotCount}\n\n`;
            
            // Generate the finalized quantum formula notation
            result += 'Finalized Quantum Formula Notation:\n';
            
            // Generate a quantum state formula based on the applied gates
            let stateFormula = '';
            
            if (gateHistory.length === 0) {
                // Initial state |0⟩^⊗n
                stateFormula = `|0⟩^{⊗${qubitCount}}`;
            } else {
                // Create a formula based on gate operations
                const hGates = gateHistory.filter(gate => gate.type === 'h');
                const xGates = gateHistory.filter(gate => gate.type === 'x');
                const yGates = gateHistory.filter(gate => gate.type === 'y');
                const zGates = gateHistory.filter(gate => gate.type === 'z');
                const cxGates = gateHistory.filter(gate => gate.type === 'cx');
                const czGates = gateHistory.filter(gate => gate.type === 'cz');
                const swapGates = gateHistory.filter(gate => gate.type === 'swap');
                
                // Build formula components
                let formulaParts = [];
                
                // Add Hadamard operations
                if (hGates.length > 0) {
                    const targets = new Set(hGates.map(g => g.target));
                    const targetsList = Array.from(targets).sort((a, b) => a - b);
                    if (targetsList.length === qubitCount) {
                        formulaParts.push(`H^{⊗${qubitCount}}`);
                    } else {
                        formulaParts.push(`H_{${targetsList.join(',')}}`);
                    }
                }
                
                // Add X operations
                if (xGates.length > 0) {
                    const targets = new Set(xGates.map(g => g.target));
                    formulaParts.push(`X_{${Array.from(targets).sort((a, b) => a - b).join(',')}}`);
                }
                
                // Add Y operations
                if (yGates.length > 0) {
                    const targets = new Set(yGates.map(g => g.target));
                    formulaParts.push(`Y_{${Array.from(targets).sort((a, b) => a - b).join(',')}}`);
                }
                
                // Add Z operations
                if (zGates.length > 0) {
                    const targets = new Set(zGates.map(g => g.target));
                    formulaParts.push(`Z_{${Array.from(targets).sort((a, b) => a - b).join(',')}}`);
                }
                
                // Add CNOT operations
                if (cxGates.length > 0) {
                    cxGates.forEach(g => {
                        formulaParts.push(`CNOT_{${g.control},${g.target}}`);
                    });
                }
                
                // Add CZ operations
                if (czGates.length > 0) {
                    czGates.forEach(g => {
                        formulaParts.push(`CZ_{${g.control},${g.target}}`);
                    });
                }
                
                // Add SWAP operations
                if (swapGates.length > 0) {
                    swapGates.forEach(g => {
                        formulaParts.push(`SWAP_{${g.control},${g.target}}`);
                    });
                }
                
                // Combine all parts
                const operators = formulaParts.join(' ');
                
                // Final formula structure
                stateFormula = `${operators} |0⟩^{⊗${qubitCount}}`;
                
                // If there's significant entanglement, add the appropriate notation
                if (cxGates.length > 0 || czGates.length > 0) {
                    // Add a more complex state representation for entangled systems
                    const entangledQubits = new Set();
                    [...cxGates, ...czGates].forEach(g => {
                        entangledQubits.add(g.control);
                        entangledQubits.add(g.target);
                    });
                    
                    // Create a simplified Bell-like state notation if appropriate
                    if (entangledQubits.size === 2 && hGates.length === 1) {
                        const qubits = Array.from(entangledQubits).sort((a, b) => a - b);
                        stateFormula = `\\frac{1}{\\sqrt{2}}(|0_{${qubits[0]}}0_{${qubits[1]}}⟩ + |1_{${qubits[0]}}1_{${qubits[1]}}⟩)`;
                    }
                }
            }
            
            result += stateFormula + '\n\n';
            
            // Add matrix representation hint
            result += 'Matrix Representation:\n';
            result += `ℋ = ℂ^{2^${qubitCount}}\n`;
            
            if (gateHistory.length > 0) {
                result += `U = ${gateHistory.map(g => g.type.toUpperCase()).join(' · ')}\n\n`;
            } else {
                result += 'U = I\n\n';
            }
            
            // Simulate measurement outcomes based on the circuit
            result += 'Measurement sampling (1000 shots):\n';
            
            // Calculate the most likely outcomes based on the circuit
            // This is a visual approximation for the UI only
            const outcomes = {};
            
            if (hadamardCount === 0 && cnotCount === 0 && 
                gateHistory.filter(gate => gate.type === 'x' || gate.type === 'y').length === 0) {
                // If no H, X, Y gates or CNOTs, the outcome is deterministic |0⟩^⊗n
                outcomes['0'.repeat(qubitCount)] = 1000;
            } else if (hadamardCount === 0 && 
                       (gateHistory.filter(gate => gate.type === 'x' || gate.type === 'y').length > 0) && 
                       cnotCount === 0) {
                // If we have X or Y gates but no H/CNOT, we have a deterministic result with some 1s
                let outcome = '';
                for (let q = 0; q < qubitCount; q++) {
                    // Check if this qubit had an odd number of X or Y gates applied
                    const xCount = gateHistory.filter(gate => 
                        (gate.type === 'x' || gate.type === 'y') && gate.target === q
                    ).length;
                    outcome += (xCount % 2 === 1) ? '1' : '0';
                }
                outcomes[outcome] = 1000;
            } else if (hadamardCount > 0 && cnotCount === 0) {
                // If only H gates and no entanglement, distribute outcomes uniformly among basis states
                const activeQubits = new Set(gateHistory.filter(gate => gate.type === 'h').map(gate => gate.target));
                const possibleOutcomes = Math.pow(2, activeQubits.size);
                
                // Generate all possible outcomes for H gates (up to a reasonable number)
                const numToGenerate = Math.min(8, possibleOutcomes);
                const shotsPerOutcome = Math.floor(1000 / numToGenerate);
                
                // Generate representative outcomes with bit flips from X/Y gates
                const xFlippedQubits = new Set();
                gateHistory.filter(gate => gate.type === 'x' || gate.type === 'y')
                    .forEach(gate => {
                        // Toggle the bit if there's an odd number of X/Y gates
                        if (xFlippedQubits.has(gate.target)) {
                            xFlippedQubits.delete(gate.target);
                        } else {
                            xFlippedQubits.add(gate.target);
                        }
                    });
                
                // Generate some number of representative outcomes
                for (let i = 0; i < numToGenerate; i++) {
                    let outcome = '';
                    for (let q = 0; q < qubitCount; q++) {
                        if (activeQubits.has(q)) {
                            // For qubits with H gates, use a deterministic but varied pattern
                            // This ensures we show different basis states each time
                            const bit = ((i >> Array.from(activeQubits).indexOf(q)) & 1) === 1 ? '1' : '0';
                            // If this qubit also had X or Y gates, flip the bit
                            outcome += xFlippedQubits.has(q) ? (bit === '0' ? '1' : '0') : bit;
                        } else if (xFlippedQubits.has(q)) {
                            // Qubits with X but no H are deterministically flipped
                            outcome += '1';
                        } else {
                            // Qubits with neither H nor X remain in |0⟩
                            outcome += '0';
                        }
                    }
                    
                    outcomes[outcome] = shotsPerOutcome;
                }
            } else {
                // Complex circuit with entanglement
                // Generate a diverse set of representative outcomes
                
                // First determine which qubits have been affected by operations
                const affectedQubits = new Set();
                gateHistory.forEach(gate => {
                    affectedQubits.add(gate.target);
                    if (gate.control !== undefined) affectedQubits.add(gate.control);
                });
                
                // For CNOT gates, create correlated outcomes
                const numOutcomes = Math.min(10, Math.pow(2, affectedQubits.size));
                const shotsPerMainOutcome = Math.floor(900 / numOutcomes); // Reserve 100 shots for random noise
                
                // Create deterministic but varied outcomes for demonstration
                for (let i = 0; i < numOutcomes; i++) {
                    let outcome = '';
                    
                    // Create a binary pattern based on the iteration
                    // This ensures we display a variety of basis states
                    for (let q = 0; q < qubitCount; q++) {
                        if (affectedQubits.has(q)) {
                            // For affected qubits, use the binary representation of i
                            const position = Array.from(affectedQubits).indexOf(q);
                            outcome += ((i >> position) & 1) === 1 ? '1' : '0';
                        } else {
                            // Unaffected qubits stay in |0⟩
                            outcome += '0';
                        }
                    }
                    
                    // Apply CNOT correlations
                    cxGates.forEach(gate => {
                        // If control is 1, target should match the control value
                        const controlIdx = gate.control;
                        const targetIdx = gate.target;
                        if (outcome[controlIdx] === '1') {
                            // Toggle target bit
                            const outcomeArray = outcome.split('');
                            outcomeArray[targetIdx] = outcomeArray[targetIdx] === '0' ? '1' : '0';
                            outcome = outcomeArray.join('');
                        }
                    });
                    
                    // Assign shots to this outcome, with some variation
                    outcomes[outcome] = Math.floor(shotsPerMainOutcome * (0.8 + Math.random() * 0.4));
                }
                
                // Add some random noise outcomes for realism
                const remainingShots = 1000 - Object.values(outcomes).reduce((sum, val) => sum + val, 0);
                if (remainingShots > 0) {
                    const noiseOutcomes = Math.min(3, Math.floor(remainingShots / 20));
                    for (let i = 0; i < noiseOutcomes; i++) {
                        let outcome = '';
                        for (let q = 0; q < qubitCount; q++) {
                            outcome += Math.random() < 0.5 ? '0' : '1';
                        }
                        
                        // Check this random outcome doesn't already exist
                        if (!outcomes[outcome]) {
                            outcomes[outcome] = Math.floor(remainingShots / noiseOutcomes);
                        }
                    }
                }
            }
            
            // Format and display outcomes
            result += '\n';
            const sortedOutcomes = Object.entries(outcomes)
                .sort((a, b) => b[1] - a[1]);  // Sort by count, descending
                
            // Calculate total shots reported
            const totalShots = sortedOutcomes.reduce((sum, [_, count]) => sum + count, 0);
            
            // Display each outcome with proper formatting
            sortedOutcomes.forEach(([state, count]) => {
                // Format the state to highlight the 1s for readability
                const formattedState = formatQuantumState(state);
                const percentage = ((count / totalShots) * 100).toFixed(1);
                
                if (state.length > 32) {
                    // For very large qubit counts, truncate the middle but show both ends
                    const firstPart = state.substring(0, 16);
                    const lastPart = state.substring(state.length - 16);
                    result += `|${formatQuantumState(firstPart)}...${formatQuantumState(lastPart)}⟩: ${count} shots (${percentage}%)\n`;
                } else {
                    result += `|${formattedState}⟩: ${count} shots (${percentage}%)\n`;
                }
            });
            
            // Helper function to format quantum states for better readability
            function formatQuantumState(state) {
                // Check if it's an all-zero state
                if (!/1/.test(state)) {
                    return state; // Keep all zeros as is
                }
                
                // For states with 1s, highlight them with bold text or color
                // Here we're adding spaces to improve readability
                let formatted = '';
                for (let i = 0; i < state.length; i++) {
                    if (i > 0 && i % 4 === 0) {
                        formatted += ' '; // Add space every 4 bits for readability
                    }
                    formatted += state[i];
                }
                return formatted;
            }
            
            return result;
        }
        
        // Initialize when window loads
        window.addEventListener('load', () => {
            updateQuantumGrid();
            updateStateDisplay();
            
            // Initialize the circuit designer
            initQuantumCircuitDesigner('circuit-designer-container');
            
            // Expose quantum state data for circuit designer
            window.quantumGridData = {
                getEigenvalues: () => eigenvalues,
                getEigenvectors: () => eigenvectors,
                applyGate: applyGateToState,
                generateNewState: generateQuantumState,
                getQubitCount: () => qubitCount
            };
            
            // Monitor window resize to update connections
            window.addEventListener('resize', () => {
                updateQuantumGrid();
            });
        });
    </script>
</body>
</html>