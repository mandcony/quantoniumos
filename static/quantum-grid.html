<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Grid</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
        }
        
        header {
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #222;
        }
        
        .logo {
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 1px;
            color: #fff;
        }
        
        .subtitle {
            font-size: 14px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            padding: 0;
            margin: 0;
            background-color: #111;
        }
        
        .tab {
            padding: 15px 20px;
            font-size: 14px;
            cursor: pointer;
            text-align: center;
            flex: 1;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
            max-width: 200px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 300;
        }
        
        .tab.active {
            border-bottom: 3px solid #00b7ff;
            color: #00b7ff;
        }
        
        .tab:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 30px;
        }
        
        .panel {
            background-color: #111;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .panel h2 {
            margin-top: 0;
            font-weight: 300;
            font-size: 18px;
            margin-bottom: 20px;
            border-bottom: 1px solid #222;
            padding-bottom: 10px;
        }
        
        .panel p {
            color: #aaa;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .quantum-grid-container {
            margin-top: 20px;
            margin-bottom: 20px;
            height: 600px;
            background-color: #0a0a0a;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }
        
        .quantum-grid {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            gap: 1px;
        }
        
        .quantum-cell {
            background-color: rgba(0, 183, 255, 0.05);
            border: 1px solid rgba(0, 183, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
        }
        
        .quantum-cell:hover {
            background-color: rgba(0, 183, 255, 0.2);
        }
        
        .quantum-cell.active {
            background-color: rgba(0, 183, 255, 0.3);
        }
        
        .control-panel {
            background-color: #0a0a0a;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .control-group {
            margin-bottom: 15px;
            flex: 1;
            min-width: 200px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            background: #333;
            height: 5px;
            -webkit-appearance: none;
            outline: none;
            border-radius: 5px;
            margin-bottom: 5px;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #00b7ff;
            border-radius: 50%;
        }
        
        .control-group input[type="number"] {
            width: 70px;
            padding: 5px 8px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 3px;
        }
        
        .control-group select {
            width: 100%;
            padding: 8px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 3px;
        }
        
        .slider-value {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            background-color: #00475e;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #00b7ff;
        }
        
        button.active {
            background-color: #00b7ff;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .overlay-content {
            background: #111;
            padding: 20px;
            border-radius: 5px;
            max-width: 500px;
            text-align: center;
        }
        
        .overlay-content h3 {
            margin-top: 0;
            color: #00b7ff;
        }
        
        .state-display {
            font-family: monospace;
            background-color: #0a0a0a;
            border-radius: 4px;
            padding: 15px;
            margin-top: 15px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .info-panel {
            background-color: rgba(0, 183, 255, 0.1);
            border-left: 3px solid #00b7ff;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .info-panel h3 {
            margin-top: 0;
            font-size: 16px;
            color: #00b7ff;
        }
        
        /* Wave animation on grid */
        @keyframes wave {
            0% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-5px);
            }
            100% {
                transform: translateY(0);
            }
        }
        
        .connection-line {
            position: absolute;
            background-color: rgba(0, 183, 255, 0.7);
            height: 2px;
            transform-origin: 0 0;
            z-index: 5;
            transition: opacity 0.3s;
        }
        
        .qubit-node {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #00b7ff;
            border-radius: 50%;
            z-index: 6;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px rgba(0, 183, 255, 0.8);
        }
        
        .qubit-node.entangled {
            background-color: #b967ff;
            box-shadow: 0 0 8px rgba(185, 103, 255, 0.8);
        }
        
        .probability-wave {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(0, 183, 255, 0.4);
            transform: translate(-50%, -50%);
            animation: wave-expand 2s infinite;
        }
        
        @keyframes wave-expand {
            0% {
                width: 0;
                height: 0;
                opacity: 0.8;
            }
            100% {
                width: 100px;
                height: 100px;
                opacity: 0;
            }
        }

        /* Gate visualization */
        .gate-tooltip {
            position: absolute;
            background-color: #000;
            color: #fff;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 10;
            pointer-events: none;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">QUANTONIUMOS</div>
        <div class="subtitle">ADVANCED QUANTUM CRYPTOGRAPHY SYSTEM</div>
    </header>
    
    <div class="tabs">
        <div class="tab" onclick="window.location.href='/resonance-encrypt'">Encryption</div>
        <div class="tab" onclick="window.location.href='/resonance-transform'">Resonance Fourier Transform</div>
        <div class="tab" onclick="window.location.href='/container-operations'">Container Operations</div>
        <div class="tab" onclick="window.location.href='/quantum-entropy'">Entropy Generator</div>
        <div class="tab active" onclick="window.location.href='/quantum-grid'">Quantum Grid</div>
        <div class="tab" onclick="window.location.href='/quantum-benchmark'">64-Perturbation Benchmark</div>
    </div>
    
    <div class="container">
        <div class="panel">
            <h2>Quantum Grid (150-Qubit Simulator)</h2>
            <p>
                This quantum circuit simulator allows you to visualize and interact with up to 150 qubits.
                Use the controls below to adjust qubit count, entanglement, and gate operations.
            </p>
            
            <div class="info-panel">
                <h3>System Status</h3>
                <p>Using quantum-inspired symbolic matrix mathematics for operations. 
                   All results are deterministic based on internal quantum simulation.</p>
            </div>
            
            <div class="control-panel">
                <div class="control-group">
                    <label for="qubit-count">Qubit Count:</label>
                    <input type="range" id="qubit-count" min="2" max="150" value="64">
                    <div class="slider-value">
                        <span>2</span>
                        <span id="qubit-count-value">64</span>
                        <span>150</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="entanglement">Entanglement Strength:</label>
                    <input type="range" id="entanglement" min="0" max="1" step="0.1" value="0.5">
                    <div class="slider-value">
                        <span>0.0</span>
                        <span id="entanglement-value">0.5</span>
                        <span>1.0</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="gate-type">Gate Type:</label>
                    <select id="gate-type">
                        <option value="h">Hadamard (H)</option>
                        <option value="x">Pauli-X</option>
                        <option value="y">Pauli-Y</option>
                        <option value="z">Pauli-Z</option>
                        <option value="cx">CNOT</option>
                        <option value="cz">CZ</option>
                        <option value="swap">SWAP</option>
                        <option value="t">T Gate</option>
                        <option value="s">S Gate</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="target-qubit">Target Qubit:</label>
                    <input type="number" id="target-qubit" min="0" max="149" value="0">
                </div>
                
                <div class="control-group">
                    <label for="control-qubit">Control Qubit (for 2-qubit gates):</label>
                    <input type="number" id="control-qubit" min="0" max="149" value="1">
                </div>
            </div>
            
            <div class="button-group">
                <button id="apply-gate">Apply Gate</button>
                <button id="reset-state">Reset State</button>
                <button id="toggle-animation">Toggle Animation</button>
                <button id="run-circuit">Run Complete Circuit</button>
            </div>
            
            <div class="quantum-grid-container">
                <div id="quantum-grid" class="quantum-grid"></div>
                <div id="overlay" class="overlay">
                    <div class="overlay-content">
                        <h3>Quantum Computation Complete</h3>
                        <p>The quantum circuit has been executed successfully.</p>
                        <div id="computation-result" class="state-display"></div>
                        <button id="close-overlay">Close</button>
                    </div>
                </div>
            </div>
            
            <div class="state-display" id="state-display">// Quantum state will appear here</div>
        </div>
    </div>
    
    <script>
        // DOM elements
        const qubitCountSlider = document.getElementById('qubit-count');
        const entanglementSlider = document.getElementById('entanglement');
        const gateTypeSelect = document.getElementById('gate-type');
        const targetQubitInput = document.getElementById('target-qubit');
        const controlQubitInput = document.getElementById('control-qubit');
        const qubitCountValue = document.getElementById('qubit-count-value');
        const entanglementValue = document.getElementById('entanglement-value');
        const applyGateButton = document.getElementById('apply-gate');
        const resetStateButton = document.getElementById('reset-state');
        const toggleAnimationButton = document.getElementById('toggle-animation');
        const runCircuitButton = document.getElementById('run-circuit');
        const quantumGrid = document.getElementById('quantum-grid');
        const stateDisplay = document.getElementById('state-display');
        const overlay = document.getElementById('overlay');
        const computationResult = document.getElementById('computation-result');
        const closeOverlayButton = document.getElementById('close-overlay');
        
        // State variables
        let qubitCount = 64;
        let entanglementStrength = 0.5;
        let gateHistory = [];
        let cells = [];
        let nodes = [];
        let connections = [];
        let animationActive = true;
        let highlightedCells = new Set();
        
        // Update value displays
        qubitCountSlider.addEventListener('input', () => {
            qubitCount = parseInt(qubitCountSlider.value);
            qubitCountValue.textContent = qubitCount;
            
            // Update max values for control and target inputs
            targetQubitInput.max = qubitCount - 1;
            controlQubitInput.max = qubitCount - 1;
            
            // Ensure current values don't exceed new max
            if (parseInt(targetQubitInput.value) >= qubitCount) {
                targetQubitInput.value = qubitCount - 1;
            }
            if (parseInt(controlQubitInput.value) >= qubitCount) {
                controlQubitInput.value = qubitCount - 1;
            }
            
            updateQuantumGrid();
            updateStateDisplay();
        });
        
        entanglementSlider.addEventListener('input', () => {
            entanglementStrength = parseFloat(entanglementSlider.value);
            entanglementValue.textContent = entanglementStrength.toFixed(1);
            updateConnections();
        });
        
        // Apply gate button
        applyGateButton.addEventListener('click', () => {
            const gateType = gateTypeSelect.value;
            const targetQubit = parseInt(targetQubitInput.value);
            const controlQubit = parseInt(controlQubitInput.value);
            
            // Validate inputs
            if (targetQubit >= qubitCount || targetQubit < 0) {
                alert(`Target qubit must be between 0 and ${qubitCount - 1}`);
                return;
            }
            
            if (['cx', 'cz', 'swap'].includes(gateType)) {
                if (controlQubit >= qubitCount || controlQubit < 0) {
                    alert(`Control qubit must be between 0 and ${qubitCount - 1}`);
                    return;
                }
                
                if (controlQubit === targetQubit) {
                    alert("Control and target qubits must be different");
                    return;
                }
            }
            
            // Add gate to history
            gateHistory.push({
                type: gateType,
                target: targetQubit,
                control: ['cx', 'cz', 'swap'].includes(gateType) ? controlQubit : null
            });
            
            // Visualize gate application
            visualizeGateApplication(gateType, targetQubit, controlQubit);
            
            // Update state display
            updateStateDisplay();
        });
        
        // Reset state button
        resetStateButton.addEventListener('click', () => {
            gateHistory = [];
            updateStateDisplay();
            clearHighlights();
        });
        
        // Toggle animation button
        toggleAnimationButton.addEventListener('click', () => {
            animationActive = !animationActive;
            toggleAnimationButton.textContent = animationActive ? 'Pause Animation' : 'Resume Animation';
            toggleAnimationButton.classList.toggle('active', animationActive);
        });
        
        // Run complete circuit button
        runCircuitButton.addEventListener('click', () => {
            if (gateHistory.length === 0) {
                alert("Please apply at least one gate before running the circuit");
                return;
            }
            
            // Show overlay with loading animation
            overlay.classList.add('active');
            
            // Simulate computation delay
            setTimeout(() => {
                // Generate a simplified result based on the circuit
                const result = generateCircuitResult();
                computationResult.textContent = result;
            }, 1500);
        });
        
        // Close overlay button
        closeOverlayButton.addEventListener('click', () => {
            overlay.classList.remove('active');
        });
        
        // Initialize quantum grid
        function initQuantumGrid() {
            // Clear existing grid
            quantumGrid.innerHTML = '';
            cells = [];
            nodes = [];
            connections = [];
            
            // Calculate grid dimensions based on qubit count
            const gridSize = Math.ceil(Math.sqrt(qubitCount));
            const columns = gridSize;
            const rows = Math.ceil(qubitCount / columns);
            
            // Update grid CSS
            quantumGrid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            quantumGrid.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            
            // Create cells
            for (let i = 0; i < qubitCount; i++) {
                const cell = document.createElement('div');
                cell.className = 'quantum-cell';
                cell.setAttribute('data-index', i);
                quantumGrid.appendChild(cell);
                cells.push(cell);
                
                // Add qubit node
                const node = document.createElement('div');
                node.className = 'qubit-node';
                node.setAttribute('data-index', i);
                
                // Position node within cell
                const rect = cell.getBoundingClientRect();
                const gridRect = quantumGrid.getBoundingClientRect();
                const x = (rect.left - gridRect.left) + rect.width / 2;
                const y = (rect.top - gridRect.top) + rect.height / 2;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                quantumGrid.appendChild(node);
                nodes.push(node);
                
                // Add probability wave
                if (animationActive) {
                    const wave = document.createElement('div');
                    wave.className = 'probability-wave';
                    wave.style.left = `${x}px`;
                    wave.style.top = `${y}px`;
                    wave.style.animationDelay = `${Math.random() * 2}s`;
                    quantumGrid.appendChild(wave);
                }
            }
            
            // Create initial connections
            updateConnections();
        }
        
        // Update connections between qubits
        function updateConnections() {
            // Remove existing connections
            connections.forEach(conn => conn.remove());
            connections = [];
            
            // Create new connections based on entanglement strength
            const gridRect = quantumGrid.getBoundingClientRect();
            
            for (let i = 0; i < nodes.length; i++) {
                const node1 = nodes[i];
                const node1Rect = node1.getBoundingClientRect();
                
                // Calculate number of connections based on entanglement strength
                const connectionCount = Math.floor(entanglementStrength * 3) + 1;
                
                // Connect to nearest nodes
                for (let j = 0; j < connectionCount; j++) {
                    // Find a node to connect to (excluding self)
                    let node2Index;
                    
                    // For structured connections
                    if (j === 0 && i < nodes.length - 1) {
                        // Connect to next node
                        node2Index = i + 1;
                    } else if (j === 1 && i + Math.sqrt(nodes.length) < nodes.length) {
                        // Connect to node below (if exists)
                        node2Index = i + Math.floor(Math.sqrt(nodes.length));
                    } else {
                        // Connect to a random node
                        do {
                            node2Index = Math.floor(Math.random() * nodes.length);
                        } while (node2Index === i);
                    }
                    
                    if (node2Index >= nodes.length) continue;
                    
                    const node2 = nodes[node2Index];
                    const node2Rect = node2.getBoundingClientRect();
                    
                    // Calculate positions
                    const x1 = node1Rect.left - gridRect.left + node1Rect.width / 2;
                    const y1 = node1Rect.top - gridRect.top + node1Rect.height / 2;
                    const x2 = node2Rect.left - gridRect.left + node2Rect.width / 2;
                    const y2 = node2Rect.top - gridRect.top + node2Rect.height / 2;
                    
                    // Calculate length and angle
                    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                    
                    // Create connection line
                    const line = document.createElement('div');
                    line.className = 'connection-line';
                    line.style.width = `${length}px`;
                    line.style.left = `${x1}px`;
                    line.style.top = `${y1}px`;
                    line.style.transform = `rotate(${angle}deg)`;
                    
                    // Only show if entanglement strength is above 0
                    line.style.opacity = entanglementStrength > 0 ? 
                        (0.3 + entanglementStrength * 0.7) : 0;
                    
                    quantumGrid.appendChild(line);
                    connections.push(line);
                }
            }
        }
        
        // Visualize gate application
        function visualizeGateApplication(gateType, targetQubit, controlQubit) {
            // Clear previous highlights
            clearHighlights();
            
            // Highlight target qubit
            if (targetQubit < cells.length) {
                cells[targetQubit].classList.add('active');
                highlightedCells.add(targetQubit);
            }
            
            // For 2-qubit gates, highlight control qubit
            if (['cx', 'cz', 'swap'].includes(gateType) && controlQubit < cells.length) {
                cells[controlQubit].classList.add('active');
                highlightedCells.add(controlQubit);
                
                // Add entanglement visualization
                nodes[targetQubit].classList.add('entangled');
                nodes[controlQubit].classList.add('entangled');
                
                // Create temporary connection if one doesn't exist
                const gridRect = quantumGrid.getBoundingClientRect();
                const node1Rect = nodes[targetQubit].getBoundingClientRect();
                const node2Rect = nodes[controlQubit].getBoundingClientRect();
                
                const x1 = node1Rect.left - gridRect.left + node1Rect.width / 2;
                const y1 = node1Rect.top - gridRect.top + node1Rect.height / 2;
                const x2 = node2Rect.left - gridRect.left + node2Rect.width / 2;
                const y2 = node2Rect.top - gridRect.top + node2Rect.height / 2;
                
                const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                
                const line = document.createElement('div');
                line.className = 'connection-line';
                line.style.width = `${length}px`;
                line.style.left = `${x1}px`;
                line.style.top = `${y1}px`;
                line.style.transform = `rotate(${angle}deg)`;
                line.style.backgroundColor = 'rgba(185, 103, 255, 0.7)';
                line.style.boxShadow = '0 0 8px rgba(185, 103, 255, 0.5)';
                line.style.zIndex = 7;
                
                quantumGrid.appendChild(line);
                connections.push(line);
                
                // Create gate visualization tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'gate-tooltip';
                tooltip.textContent = gateTypeToLabel(gateType);
                tooltip.style.left = `${(x1 + x2) / 2}px`;
                tooltip.style.top = `${(y1 + y2) / 2}px`;
                tooltip.style.opacity = 1;
                
                quantumGrid.appendChild(tooltip);
                
                // Remove gate visualization after a delay
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                    setTimeout(() => tooltip.remove(), 300);
                }, 2000);
            } else {
                // Single qubit gate - create gate tooltip
                const nodeRect = nodes[targetQubit].getBoundingClientRect();
                const gridRect = quantumGrid.getBoundingClientRect();
                const x = nodeRect.left - gridRect.left + nodeRect.width / 2;
                const y = nodeRect.top - gridRect.top + nodeRect.height / 2;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'gate-tooltip';
                tooltip.textContent = gateTypeToLabel(gateType);
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;
                tooltip.style.opacity = 1;
                
                quantumGrid.appendChild(tooltip);
                
                // Remove gate visualization after a delay
                setTimeout(() => {
                    tooltip.style.opacity = 0;
                    setTimeout(() => tooltip.remove(), 300);
                }, 2000);
            }
            
            // Remove highlights after a delay
            setTimeout(() => {
                clearHighlights();
            }, 2500);
        }
        
        // Clear highlights
        function clearHighlights() {
            highlightedCells.forEach(index => {
                if (index < cells.length) {
                    cells[index].classList.remove('active');
                }
            });
            
            nodes.forEach(node => {
                node.classList.remove('entangled');
            });
            
            highlightedCells.clear();
        }
        
        // Convert gate type to human-readable label
        function gateTypeToLabel(gateType) {
            const labels = {
                'h': 'H',
                'x': 'X',
                'y': 'Y',
                'z': 'Z',
                'cx': 'CNOT',
                'cz': 'CZ',
                'swap': 'SWAP',
                't': 'T',
                's': 'S'
            };
            
            return labels[gateType] || gateType.toUpperCase();
        }
        
        // Update quantum grid
        function updateQuantumGrid() {
            initQuantumGrid();
        }
        
        // Update state display
        function updateStateDisplay() {
            // Generate a simplified state representation based on the circuit
            let stateText = '// Quantum State';
            
            if (gateHistory.length === 0) {
                stateText += '\nInitial state: |';
                for (let i = 0; i < qubitCount; i++) {
                    stateText += '0';
                }
                stateText += '⟩';
                
                // Add formula notation for initial state
                stateText += '\n\nQuantum Formula: |0⟩^{⊗' + qubitCount + '}';
            } else {
                stateText += '\nCircuit:';
                
                gateHistory.forEach((gate, index) => {
                    stateText += `\n${index + 1}. ${gateTypeToLabel(gate.type)} gate`;
                    
                    if (gate.control !== null) {
                        stateText += ` with control=${gate.control}, target=${gate.target}`;
                    } else {
                        stateText += ` on qubit ${gate.target}`;
                    }
                });
                
                // Show a simplified final state
                stateText += '\n\nFinal state: Complex superposition of ';
                
                // Calculate a simplified count of basis states in the superposition
                // This is a visual approximation for the UI only
                const basisStates = Math.min(Math.pow(2, Math.min(gateHistory.length + 1, 10)), Math.pow(2, qubitCount));
                stateText += `${basisStates} basis states`;
                
                // Add simplified quantum formula notation
                stateText += '\n\nQuantum Formula: ';
                
                // Create a simple gate sequence notation
                const hadamardGates = gateHistory.filter(gate => gate.type === 'h');
                const cnotGates = gateHistory.filter(gate => gate.type === 'cx');
                
                if (hadamardGates.length === 0 && cnotGates.length === 0) {
                    // Just basic gates without superposition or entanglement
                    stateText += `U|0⟩^{⊗${qubitCount}}`;
                } else if (hadamardGates.length > 0 && cnotGates.length === 0) {
                    // Superposition but no entanglement
                    const hTargets = [...new Set(hadamardGates.map(g => g.target))].sort((a, b) => a - b);
                    
                    if (hTargets.length === qubitCount) {
                        // All qubits in superposition
                        stateText += `H^{⊗${qubitCount}}|0⟩^{⊗${qubitCount}} = \\frac{1}{\\sqrt{2^${qubitCount}}}\\sum_{i=0}^{2^${qubitCount}-1}|i⟩`;
                    } else {
                        // Some qubits in superposition
                        stateText += `H_{${hTargets.join(',')}}|0⟩^{⊗${qubitCount}}`;
                    }
                } else if (cnotGates.length > 0) {
                    // Entanglement present
                    if (hadamardGates.length === 1 && cnotGates.length === 1 && 
                        hadamardGates[0].target === cnotGates[0].control) {
                        // Typical Bell state preparation
                        const control = cnotGates[0].control;
                        const target = cnotGates[0].target;
                        stateText += `CNOT_{${control},${target}}H_{${control}}|0⟩^{⊗${qubitCount}} = \\frac{1}{\\sqrt{2}}(|0_{${control}}0_{${target}}⟩ + |1_{${control}}1_{${target}}⟩) ⊗ |0⟩^{⊗${qubitCount-2}}`;
                    } else {
                        // General entangled state
                        stateText += `U|0⟩^{⊗${qubitCount}} (see full formula after running circuit)`;
                    }
                }
            }
            
            stateDisplay.textContent = stateText;
        }
        
        // Generate a simulated result for the quantum circuit
        function generateCircuitResult() {
            const gateCount = gateHistory.length;
            const hadamardCount = gateHistory.filter(gate => gate.type === 'h').length;
            const cnotCount = gateHistory.filter(gate => gate.type === 'cx').length;
            
            let result = '// Quantum Circuit Execution Results\n';
            result += `Circuit depth: ${gateCount}\n`;
            result += `Qubit count: ${qubitCount}\n`;
            result += `Hadamard gates: ${hadamardCount}\n`;
            result += `CNOT gates: ${cnotCount}\n\n`;
            
            // Generate the finalized quantum formula notation
            result += 'Finalized Quantum Formula Notation:\n';
            
            // Generate a quantum state formula based on the applied gates
            let stateFormula = '';
            
            if (gateHistory.length === 0) {
                // Initial state |0⟩^⊗n
                stateFormula = `|0⟩^{⊗${qubitCount}}`;
            } else {
                // Create a formula based on gate operations
                const hGates = gateHistory.filter(gate => gate.type === 'h');
                const xGates = gateHistory.filter(gate => gate.type === 'x');
                const yGates = gateHistory.filter(gate => gate.type === 'y');
                const zGates = gateHistory.filter(gate => gate.type === 'z');
                const cxGates = gateHistory.filter(gate => gate.type === 'cx');
                const czGates = gateHistory.filter(gate => gate.type === 'cz');
                const swapGates = gateHistory.filter(gate => gate.type === 'swap');
                
                // Build formula components
                let formulaParts = [];
                
                // Add Hadamard operations
                if (hGates.length > 0) {
                    const targets = new Set(hGates.map(g => g.target));
                    const targetsList = Array.from(targets).sort((a, b) => a - b);
                    if (targetsList.length === qubitCount) {
                        formulaParts.push(`H^{⊗${qubitCount}}`);
                    } else {
                        formulaParts.push(`H_{${targetsList.join(',')}}`);
                    }
                }
                
                // Add X operations
                if (xGates.length > 0) {
                    const targets = new Set(xGates.map(g => g.target));
                    formulaParts.push(`X_{${Array.from(targets).sort((a, b) => a - b).join(',')}}`);
                }
                
                // Add Y operations
                if (yGates.length > 0) {
                    const targets = new Set(yGates.map(g => g.target));
                    formulaParts.push(`Y_{${Array.from(targets).sort((a, b) => a - b).join(',')}}`);
                }
                
                // Add Z operations
                if (zGates.length > 0) {
                    const targets = new Set(zGates.map(g => g.target));
                    formulaParts.push(`Z_{${Array.from(targets).sort((a, b) => a - b).join(',')}}`);
                }
                
                // Add CNOT operations
                if (cxGates.length > 0) {
                    cxGates.forEach(g => {
                        formulaParts.push(`CNOT_{${g.control},${g.target}}`);
                    });
                }
                
                // Add CZ operations
                if (czGates.length > 0) {
                    czGates.forEach(g => {
                        formulaParts.push(`CZ_{${g.control},${g.target}}`);
                    });
                }
                
                // Add SWAP operations
                if (swapGates.length > 0) {
                    swapGates.forEach(g => {
                        formulaParts.push(`SWAP_{${g.control},${g.target}}`);
                    });
                }
                
                // Combine all parts
                const operators = formulaParts.join(' ');
                
                // Final formula structure
                stateFormula = `${operators} |0⟩^{⊗${qubitCount}}`;
                
                // If there's significant entanglement, add the appropriate notation
                if (cxGates.length > 0 || czGates.length > 0) {
                    // Add a more complex state representation for entangled systems
                    const entangledQubits = new Set();
                    [...cxGates, ...czGates].forEach(g => {
                        entangledQubits.add(g.control);
                        entangledQubits.add(g.target);
                    });
                    
                    // Create a simplified Bell-like state notation if appropriate
                    if (entangledQubits.size === 2 && hGates.length === 1) {
                        const qubits = Array.from(entangledQubits).sort((a, b) => a - b);
                        stateFormula = `\\frac{1}{\\sqrt{2}}(|0_{${qubits[0]}}0_{${qubits[1]}}⟩ + |1_{${qubits[0]}}1_{${qubits[1]}}⟩)`;
                    }
                }
            }
            
            result += stateFormula + '\n\n';
            
            // Add matrix representation hint
            result += 'Matrix Representation:\n';
            result += `ℋ = ℂ^{2^${qubitCount}}\n`;
            
            if (gateHistory.length > 0) {
                result += `U = ${gateHistory.map(g => g.type.toUpperCase()).join(' · ')}\n\n`;
            } else {
                result += 'U = I\n\n';
            }
            
            // Simulate measurement outcomes based on the circuit
            result += 'Measurement sampling (1000 shots):\n';
            
            // Calculate the most likely outcomes based on the circuit
            // This is a visual approximation for the UI only
            const outcomes = {};
            
            if (hadamardCount === 0 && cnotCount === 0) {
                // If no H gates or CNOTs, the outcome is deterministic
                outcomes['0'.repeat(qubitCount)] = 1000;
            } else if (hadamardCount > 0 && cnotCount === 0) {
                // If only H gates, distribute outcomes uniformly among basis states
                const activeQubits = new Set(gateHistory.filter(gate => gate.type === 'h').map(gate => gate.target));
                const possibleOutcomes = Math.pow(2, activeQubits.size);
                
                // Generate representative outcomes
                for (let i = 0; i < Math.min(5, possibleOutcomes); i++) {
                    let outcome = '';
                    for (let q = 0; q < qubitCount; q++) {
                        if (activeQubits.has(q)) {
                            // Randomly 0 or 1 for qubits with H gates
                            outcome += Math.random() < 0.5 ? '0' : '1';
                        } else {
                            // Always 0 for qubits without H gates
                            outcome += '0';
                        }
                    }
                    
                    const count = Math.floor(1000 / possibleOutcomes);
                    outcomes[outcome] = count;
                }
            } else {
                // Complex circuit with entanglement
                // Generate a few representative outcomes
                for (let i = 0; i < 5; i++) {
                    let outcome = '';
                    for (let q = 0; q < qubitCount; q++) {
                        // For simplicity in the UI, generate random outcomes
                        outcome += Math.random() < 0.5 ? '0' : '1';
                    }
                    
                    // Assign somewhat random counts
                    const count = Math.floor(200 + Math.random() * 200);
                    outcomes[outcome] = count;
                }
            }
            
            // Display outcomes
            Object.entries(outcomes)
                .sort((a, b) => b[1] - a[1])  // Sort by count, descending
                .forEach(([state, count]) => {
                    if (state.length > 20) {
                        // Truncate long states
                        result += `|${state.substring(0, 10)}...${state.substring(state.length - 10)}⟩: ${count} shots\n`;
                    } else {
                        result += `|${state}⟩: ${count} shots\n`;
                    }
                });
            
            return result;
        }
        
        // Initialize when window loads
        window.addEventListener('load', () => {
            updateQuantumGrid();
            updateStateDisplay();
            
            // Monitor window resize to update connections
            window.addEventListener('resize', () => {
                updateQuantumGrid();
            });
        });
    </script>
</body>
</html>