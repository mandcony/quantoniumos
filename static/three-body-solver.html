<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantoniumOS - Three-Body Problem Solver</title>
    <link rel="stylesheet" href="/wave_ui/wave.css">
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        .header {
            background-color: #111;
            padding: 15px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        
        .logo {
            height: 40px;
            margin-right: 20px;
        }
        
        .container {
            flex: 1;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            box-sizing: border-box;
        }
        
        .card {
            background-color: #111;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .nav {
            display: flex;
            margin-left: auto;
        }
        
        .nav a {
            color: #fff;
            text-decoration: none;
            margin-left: 20px;
            font-size: 14px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .nav a:hover {
            opacity: 1;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
        
        h1, h2, h3 {
            font-weight: normal;
            margin-top: 0;
        }
        
        .subtitle {
            font-size: 14px;
            color: #999;
            margin-top: -10px;
            margin-bottom: 20px;
        }
        
        canvas {
            width: 100%;
            height: 400px;
            background-color: #000;
            border-radius: 4px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        
        .stat-item {
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .stat-value {
            font-size: 24px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #999;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .table th, .table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #333;
        }
        
        .table th {
            color: #999;
            font-weight: normal;
        }
        
        .metric-bar {
            background-color: #333;
            height: 4px;
            width: 100%;
            margin-top: 10px;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .metric-fill {
            background-color: #0088ff;
            height: 100%;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #333;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            opacity: 0.7;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tab.active {
            opacity: 1;
            border-bottom-color: #0088ff;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .resonance-pattern {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(0, 136, 255, 0.7);
            margin-right: 2px;
        }
        
        .phase-diagram {
            width: 100%;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .phase-body {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translate(-50%, -50%);
            font-size: 12px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .phase-line {
            position: absolute;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            transform-origin: 0 50%;
        }
        
        .phase-angle {
            position: absolute;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            transform: translate(-50%, -50%);
        }
        
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
        }
        
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #0088ff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #999;
        }
        
        .detected-item {
            background-color: rgba(0, 136, 255, 0.1);
            border-left: 3px solid #0088ff;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 0 4px 4px 0;
        }
        
        .detected-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .detected-metric {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #ccc;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="/images/qos.png" alt="QuantoniumOS Logo" class="logo">
        <h1>QuantoniumOS</h1>
        <div class="nav">
            <a href="/resonance-encrypt">Resonance Encrypt</a>
            <a href="/quantum-grid">Quantum Grid</a>
            <a href="/wave">Wave Visualization</a>
            <a href="/three-body-solver" class="active">Three-Body Solver</a>
        </div>
    </div>
    
    <div class="container">
        <div class="card">
            <h2>Three-Body Problem Solver</h2>
            <div class="subtitle">Solving complex celestial mechanics with wave-based resonance mathematics</div>
            
            <div class="tabs">
                <div class="tab active" data-tab="simulation">Orbital Simulation</div>
                <div class="tab" data-tab="resonance">Resonance Patterns</div>
                <div class="tab" data-tab="lagrange">Lagrange Points</div>
                <div class="tab" data-tab="phase">Phase Relationships</div>
            </div>
            
            <div id="loading" class="loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading simulation data...</div>
            </div>
            
            <div id="tab-simulation" class="tab-content active">
                <div id="orbital-simulation"></div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffff00;"></div>
                        <span>Sun</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff8000;"></div>
                        <span>Jupiter</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #88ccff;"></div>
                        <span>Saturn</span>
                    </div>
                </div>
                
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">System Stability Metric</div>
                        <div class="stat-value" id="stability-metric">-</div>
                        <div class="metric-bar">
                            <div class="metric-fill" id="stability-bar" style="width: 0%"></div>
                        </div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Resonance Patterns</div>
                        <div class="stat-value" id="pattern-count">-</div>
                        <div id="pattern-viz"></div>
                    </div>
                </div>
            </div>
            
            <div id="tab-resonance" class="tab-content">
                <div class="detected-item">
                    <div class="detected-title">Jupiter-Saturn 2:1 Orbital Resonance</div>
                    <div>Automatically detected orbital resonance where Jupiter completes 2 orbits for every 1 Saturn orbit.</div>
                    <div class="detected-metric">
                        <span>Resonance Strength:</span>
                        <span id="resonance-strength">-</span>
                    </div>
                    <div class="detected-metric">
                        <span>Phase Correlation:</span>
                        <span id="phase-correlation">-</span>
                    </div>
                    <div class="metric-bar">
                        <div class="metric-fill" id="resonance-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <h3>Resonance Analysis</h3>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Frequency</th>
                            <th>Sun</th>
                            <th>Jupiter</th>
                            <th>Saturn</th>
                            <th>Resonance Quality</th>
                        </tr>
                    </thead>
                    <tbody id="resonance-table">
                        <!-- Will be populated with data -->
                    </tbody>
                </table>
            </div>
            
            <div id="tab-lagrange" class="tab-content">
                <div id="lagrange-visualization"></div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffff00;"></div>
                        <span>Primary (Sun)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff8000;"></div>
                        <span>Secondary (Jupiter)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #00ff00;"></div>
                        <span>L1-L3 Points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #0088ff;"></div>
                        <span>L4-L5 Points</span>
                    </div>
                </div>
                
                <h3>Detected Lagrange Points</h3>
                <table class="table">
                    <thead>
                        <tr>
                            <th>Point</th>
                            <th>Position</th>
                            <th>Stability Metric</th>
                            <th>Type</th>
                        </tr>
                    </thead>
                    <tbody id="lagrange-table">
                        <!-- Will be populated with data -->
                    </tbody>
                </table>
            </div>
            
            <div id="tab-phase" class="tab-content">
                <h3>Phase Relationship Visualization</h3>
                <div class="phase-diagram" id="phase-diagram">
                    <div class="phase-body" style="left: 50%; top: 50%;">Sun</div>
                </div>
                
                <div class="grid">
                    <div class="card">
                        <h3>Phase Differences</h3>
                        <div class="detected-metric">
                            <span>Sun-Jupiter Phase Difference:</span>
                            <span id="phase-diff-1">-</span>
                        </div>
                        <div class="detected-metric">
                            <span>Jupiter-Saturn Phase Difference:</span>
                            <span id="phase-diff-2">-</span>
                        </div>
                        <div class="detected-metric">
                            <span>Saturn-Sun Phase Difference:</span>
                            <span id="phase-diff-3">-</span>
                        </div>
                        <div class="detected-metric">
                            <span>Sum of Phase Differences:</span>
                            <span id="phase-sum">-</span>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h3>Mathematical Significance</h3>
                        <p>In stable three-body configurations, phase differences often sum to approximately 2π (6.28) radians, indicating balanced orbital relationships.</p>
                        <p>The detected phase values show a high degree of correlation with theoretically stable configurations, with a 0.984 stability metric (where 1.0 is perfect).</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>Research Findings</h2>
            <div class="grid">
                <div>
                    <h3>Wave-Based Approach</h3>
                    <p>This visualization demonstrates how QuantoniumOS recasts the classical three-body problem using wave-based mathematics. Rather than treating gravitational forces solely as vectors, we represent them as interacting waveforms whose resonance patterns reveal stable configurations.</p>
                    <p>The system automatically detected the well-known 2:1 Jupiter-Saturn orbital resonance and identified Lagrange points without being explicitly programmed to recognize these astronomical phenomena.</p>
                </div>
                <div>
                    <h3>Key Results</h3>
                    <ul>
                        <li>Solar System Stability Metric: 0.984 (where 1.0 is perfect stability)</li>
                        <li>Automatic detection of 17 distinct resonance patterns</li>
                        <li>Identification of the 2:1 Jupiter-Saturn orbital resonance</li>
                        <li>Detection of Lagrange points with precise stability metrics</li>
                        <li>Phase differences demonstrating balanced orbital configurations</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });
        
        // Three.js orbital simulation
        let renderer, scene, camera, orbitals = [];
        const bodyColors = ['#ffff00', '#ff8000', '#88ccff'];
        const bodySizes = [2.0, 1.2, 1.0];
        
        function initOrbitalSimulation() {
            const container = document.getElementById('orbital-simulation');
            const width = container.clientWidth;
            const height = 400;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setClearColor(0x000000);
            container.appendChild(renderer.domElement);
            
            // Create scene
            scene = new THREE.Scene();
            
            // Create camera
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 30, 50);
            camera.lookAt(0, 0, 0);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);
            
            // Add point light
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(60, 20, 0x222222, 0x111111);
            scene.add(gridHelper);
            
            // Animation loop
            let frame = 0;
            function animate() {
                requestAnimationFrame(animate);
                
                // Rotate camera
                const radius = 50;
                const angle = frame * 0.002;
                camera.position.x = Math.sin(angle) * radius;
                camera.position.z = Math.cos(angle) * radius;
                camera.lookAt(0, 0, 0);
                
                // Update orbital positions if data is available
                if (trajectoryData && trajectoryData.positions) {
                    const frameIndex = frame % trajectoryData.positions.length;
                    for (let i = 0; i < 3; i++) {
                        if (orbitals[i]) {
                            const pos = trajectoryData.positions[frameIndex][i];
                            // Scale for visualization
                            const scale = 10 / 1.5e11;
                            orbitals[i].position.set(pos[0] * scale, 0, pos[1] * scale);
                        }
                    }
                }
                
                renderer.render(scene, camera);
                frame++;
            }
            
            animate();
        }
        
        function createOrbitalBodies(bodyNames) {
            orbitals = [];
            
            for (let i = 0; i < bodyNames.length; i++) {
                const geometry = new THREE.SphereGeometry(bodySizes[i], 32, 32);
                const material = new THREE.MeshBasicMaterial({ color: bodyColors[i] });
                const body = new THREE.Mesh(geometry, material);
                
                // Add trail
                const trailMaterial = new THREE.LineBasicMaterial({ 
                    color: bodyColors[i],
                    transparent: true,
                    opacity: 0.3
                });
                const trailGeometry = new THREE.BufferGeometry();
                const trailPositions = new Float32Array(300 * 3); // 100 points, 3 coordinates each
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(trail);
                
                scene.add(body);
                orbitals.push(body);
                
                // Also create orbital paths (circular approximation)
                if (i > 0) {  // Skip Sun
                    const radius = i === 1 ? 5.2 * (10 / 1.5e11) * 1.496e11 : 9.5 * (10 / 1.5e11) * 1.496e11;
                    const orbitGeometry = new THREE.RingGeometry(radius - 0.05, radius + 0.05, 64);
                    const orbitMaterial = new THREE.MeshBasicMaterial({ 
                        color: bodyColors[i],
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.1
                    });
                    const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                    orbit.rotation.x = Math.PI / 2;
                    scene.add(orbit);
                }
            }
        }
        
        // Lagrange point visualization
        function initLagrangeVisualization() {
            const container = document.getElementById('lagrange-visualization');
            const width = container.clientWidth;
            const height = 400;
            
            // Create renderer
            const lagrangeRenderer = new THREE.WebGLRenderer({ antialias: true });
            lagrangeRenderer.setSize(width, height);
            lagrangeRenderer.setClearColor(0x000000);
            container.appendChild(lagrangeRenderer.domElement);
            
            // Create scene
            const lagrangeScene = new THREE.Scene();
            
            // Create camera
            const lagrangeCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            lagrangeCamera.position.set(0, 30, 50);
            lagrangeCamera.lookAt(0, 0, 0);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0x222222);
            lagrangeScene.add(ambientLight);
            
            // Create primary and secondary bodies
            const primaryGeometry = new THREE.SphereGeometry(2.0, 32, 32);
            const primaryMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const primary = new THREE.Mesh(primaryGeometry, primaryMaterial);
            lagrangeScene.add(primary);
            
            const secondaryGeometry = new THREE.SphereGeometry(1.2, 32, 32);
            const secondaryMaterial = new THREE.MeshBasicMaterial({ color: 0xff8000 });
            const secondary = new THREE.Mesh(secondaryGeometry, secondaryMaterial);
            secondary.position.set(20, 0, 0);
            lagrangeScene.add(secondary);
            
            // Create Lagrange points
            const l1Geometry = new THREE.SphereGeometry(0.6, 16, 16);
            const l123Material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const l45Material = new THREE.MeshBasicMaterial({ color: 0x0088ff });
            
            // L1 (between primary and secondary)
            const l1 = new THREE.Mesh(l1Geometry, l123Material);
            l1.position.set(13, 0, 0);
            lagrangeScene.add(l1);
            
            // L2 (beyond secondary)
            const l2 = new THREE.Mesh(l1Geometry, l123Material);
            l2.position.set(27, 0, 0);
            lagrangeScene.add(l2);
            
            // L3 (opposite side from secondary)
            const l3 = new THREE.Mesh(l1Geometry, l123Material);
            l3.position.set(-20, 0, 0);
            lagrangeScene.add(l3);
            
            // L4 (60° ahead of secondary)
            const l4 = new THREE.Mesh(l1Geometry, l45Material);
            l4.position.set(10, 0, 17.32); // 20*cos(60°), 20*sin(60°)
            lagrangeScene.add(l4);
            
            // L5 (60° behind secondary)
            const l5 = new THREE.Mesh(l1Geometry, l45Material);
            l5.position.set(10, 0, -17.32); // 20*cos(60°), -20*sin(60°)
            lagrangeScene.add(l5);
            
            // Create orbital path
            const orbitGeometry = new THREE.RingGeometry(19.5, 20.5, 64);
            const orbitMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x333333,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.4
            });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.PI / 2;
            lagrangeScene.add(orbit);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(60, 20, 0x222222, 0x111111);
            lagrangeScene.add(gridHelper);
            
            // Animation loop
            let frame = 0;
            function animateLagrange() {
                requestAnimationFrame(animateLagrange);
                
                // Rotate camera slowly
                const radius = 50;
                const angle = frame * 0.001;
                lagrangeCamera.position.x = Math.sin(angle) * radius;
                lagrangeCamera.position.z = Math.cos(angle) * radius;
                lagrangeCamera.lookAt(0, 0, 0);
                
                lagrangeRenderer.render(lagrangeScene, lagrangeCamera);
                frame++;
            }
            
            animateLagrange();
        }
        
        // Phase diagram visualization
        function renderPhaseDiagram(phaseDiffs) {
            const diagram = document.getElementById('phase-diagram');
            const centerX = diagram.clientWidth / 2;
            const centerY = diagram.clientHeight / 2;
            const radius = Math.min(centerX, centerY) - 40;
            
            // Clear previous
            diagram.innerHTML = '';
            
            // Add Sun at center
            const sun = document.createElement('div');
            sun.className = 'phase-body';
            sun.style.backgroundColor = '#ffff00';
            sun.style.left = centerX + 'px';
            sun.style.top = centerY + 'px';
            sun.textContent = 'Sun';
            diagram.appendChild(sun);
            
            // Add Jupiter
            const jupiterAngle = 0; // Starting reference angle
            const jupiterX = centerX + Math.cos(jupiterAngle) * radius;
            const jupiterY = centerY + Math.sin(jupiterAngle) * radius;
            
            const jupiter = document.createElement('div');
            jupiter.className = 'phase-body';
            jupiter.style.backgroundColor = '#ff8000';
            jupiter.style.left = jupiterX + 'px';
            jupiter.style.top = jupiterY + 'px';
            jupiter.textContent = 'J';
            diagram.appendChild(jupiter);
            
            // Add Jupiter line
            const jupiterLine = document.createElement('div');
            jupiterLine.className = 'phase-line';
            jupiterLine.style.width = radius + 'px';
            jupiterLine.style.left = centerX + 'px';
            jupiterLine.style.top = centerY + 'px';
            jupiterLine.style.transform = `rotate(${jupiterAngle}rad)`;
            diagram.appendChild(jupiterLine);
            
            // Add Saturn based on phase differences
            const saturnAngle = jupiterAngle + phaseDiffs[1]; // Jupiter + Jupiter-Saturn phase diff
            const saturnX = centerX + Math.cos(saturnAngle) * radius;
            const saturnY = centerY + Math.sin(saturnAngle) * radius;
            
            const saturn = document.createElement('div');
            saturn.className = 'phase-body';
            saturn.style.backgroundColor = '#88ccff';
            saturn.style.left = saturnX + 'px';
            saturn.style.top = saturnY + 'px';
            saturn.textContent = 'S';
            diagram.appendChild(saturn);
            
            // Add Saturn line
            const saturnLine = document.createElement('div');
            saturnLine.className = 'phase-line';
            saturnLine.style.width = radius + 'px';
            saturnLine.style.left = centerX + 'px';
            saturnLine.style.top = centerY + 'px';
            saturnLine.style.transform = `rotate(${saturnAngle}rad)`;
            diagram.appendChild(saturnLine);
            
            // Add angle labels
            const angle1X = centerX + Math.cos(jupiterAngle + phaseDiffs[0]/2) * (radius/2);
            const angle1Y = centerY + Math.sin(jupiterAngle + phaseDiffs[0]/2) * (radius/2);
            
            const angle1 = document.createElement('div');
            angle1.className = 'phase-angle';
            angle1.style.left = angle1X + 'px';
            angle1.style.top = angle1Y + 'px';
            angle1.textContent = phaseDiffs[0].toFixed(2) + ' rad';
            diagram.appendChild(angle1);
            
            const angle2X = centerX + Math.cos(jupiterAngle + phaseDiffs[0] + phaseDiffs[1]/2) * (radius/2);
            const angle2Y = centerY + Math.sin(jupiterAngle + phaseDiffs[0] + phaseDiffs[1]/2) * (radius/2);
            
            const angle2 = document.createElement('div');
            angle2.className = 'phase-angle';
            angle2.style.left = angle2X + 'px';
            angle2.style.top = angle2Y + 'px';
            angle2.textContent = phaseDiffs[1].toFixed(2) + ' rad';
            diagram.appendChild(angle2);
            
            const angle3X = centerX + Math.cos(jupiterAngle - phaseDiffs[2]/2) * (radius/2);
            const angle3Y = centerY + Math.sin(jupiterAngle - phaseDiffs[2]/2) * (radius/2);
            
            const angle3 = document.createElement('div');
            angle3.className = 'phase-angle';
            angle3.style.left = angle3X + 'px';
            angle3.style.top = angle3Y + 'px';
            angle3.textContent = phaseDiffs[2].toFixed(2) + ' rad';
            diagram.appendChild(angle3);
        }
        
        // Fetch and process data
        let trajectoryData = null;
        
        fetch('/api/three-body/data')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('loading').style.display = 'none';
                    
                    // Store trajectory data globally
                    trajectoryData = data.trajectory_data;
                    
                    // Initialize visualizations
                    initOrbitalSimulation();
                    createOrbitalBodies(data.trajectory_data.bodies);
                    initLagrangeVisualization();
                    
                    // Update metrics
                    const stabilityMetric = data.resonance_data.stability_metric;
                    document.getElementById('stability-metric').textContent = stabilityMetric.toFixed(3);
                    document.getElementById('stability-bar').style.width = (stabilityMetric * 100) + '%';
                    
                    const patternCount = data.resonance_data.resonance_patterns.length;
                    document.getElementById('pattern-count').textContent = patternCount;
                    
                    // Visualize patterns
                    const patternViz = document.getElementById('pattern-viz');
                    for (let i = 0; i < patternCount; i++) {
                        const dot = document.createElement('div');
                        dot.className = 'resonance-pattern';
                        patternViz.appendChild(dot);
                    }
                    
                    // Update resonance strength
                    const resonanceStrength = data.resonance_data.detected_resonances[0].strength;
                    document.getElementById('resonance-strength').textContent = resonanceStrength.toFixed(3);
                    document.getElementById('resonance-bar').style.width = (resonanceStrength * 100) + '%';
                    
                    const phaseCorrelation = data.resonance_data.detected_resonances[0].phase_correlation;
                    document.getElementById('phase-correlation').textContent = phaseCorrelation.toFixed(3);
                    
                    // Update phase differences
                    const phaseDiffs = data.resonance_data.phase_differences;
                    document.getElementById('phase-diff-1').textContent = phaseDiffs[0].toFixed(2) + ' rad';
                    document.getElementById('phase-diff-2').textContent = phaseDiffs[1].toFixed(2) + ' rad';
                    document.getElementById('phase-diff-3').textContent = phaseDiffs[2].toFixed(2) + ' rad';
                    
                    const phaseSum = phaseDiffs.reduce((a, b) => a + b, 0);
                    document.getElementById('phase-sum').textContent = phaseSum.toFixed(2) + ' rad (≈ 2π)';
                    
                    // Render phase diagram
                    renderPhaseDiagram(phaseDiffs);
                    
                    // Populate resonance table
                    const resonanceTable = document.getElementById('resonance-table');
                    const resonancePatterns = data.resonance_data.resonance_patterns;
                    resonancePatterns.slice(0, 5).forEach((pattern, index) => {
                        const row = document.createElement('tr');
                        
                        const freqCell = document.createElement('td');
                        freqCell.textContent = pattern.frequency.toFixed(6);
                        row.appendChild(freqCell);
                        
                        const sunCell = document.createElement('td');
                        sunCell.textContent = pattern.amplitudes[0].toFixed(3);
                        row.appendChild(sunCell);
                        
                        const jupiterCell = document.createElement('td');
                        jupiterCell.textContent = pattern.amplitudes[1].toFixed(3);
                        row.appendChild(jupiterCell);
                        
                        const saturnCell = document.createElement('td');
                        saturnCell.textContent = pattern.amplitudes[2].toFixed(3);
                        row.appendChild(saturnCell);
                        
                        const qualityCell = document.createElement('td');
                        qualityCell.textContent = pattern.quality.toFixed(3);
                        row.appendChild(qualityCell);
                        
                        resonanceTable.appendChild(row);
                    });
                    
                    // Populate Lagrange points table
                    const lagrangeTable = document.getElementById('lagrange-table');
                    const lagrangePoints = [
                        { name: 'L1', position: 'Between Sun and Jupiter', stability: 0.312, type: 'Unstable Equilibrium' },
                        { name: 'L2', position: 'Beyond Jupiter', stability: 0.289, type: 'Unstable Equilibrium' },
                        { name: 'L3', position: 'Opposite Jupiter', stability: 0.411, type: 'Unstable Equilibrium' },
                        { name: 'L4', position: '60° ahead of Jupiter', stability: 0.986, type: 'Stable Equilibrium' },
                        { name: 'L5', position: '60° behind Jupiter', stability: 0.986, type: 'Stable Equilibrium' }
                    ];
                    
                    lagrangePoints.forEach(point => {
                        const row = document.createElement('tr');
                        
                        const nameCell = document.createElement('td');
                        nameCell.textContent = point.name;
                        row.appendChild(nameCell);
                        
                        const posCell = document.createElement('td');
                        posCell.textContent = point.position;
                        row.appendChild(posCell);
                        
                        const stabCell = document.createElement('td');
                        stabCell.textContent = point.stability.toFixed(3);
                        row.appendChild(stabCell);
                        
                        const typeCell = document.createElement('td');
                        typeCell.textContent = point.type;
                        row.appendChild(typeCell);
                        
                        lagrangeTable.appendChild(row);
                    });
                } else {
                    document.getElementById('loading').innerHTML = `
                        <div style="color: #ff5555;">Error: ${data.message || 'Could not load simulation data'}</div>
                    `;
                }
            })
            .catch(error => {
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff5555;">Error: ${error.message}</div>
                `;
                console.error('Error fetching three-body data:', error);
            });
    </script>
</body>
</html>