\documentclass[conference,letterpaper,10pt]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage{microtype}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{url}

% === GARAMOND (EB Garamond – beautiful, open-source, professional) ===
% \usepackage{ebgaramond}          % Main text: EB Garamond
% \usepackage{ebgaramond-maths}    % Matching math symbols
% \usepackage[sans-serif,scaled=0.92]{libertine}  % Headings in Libertine sans (pairs nicely)

% QuantoniumOS deep blue
\definecolor{quantblue}{RGB}{0,74,173}

% Elegant blue headings
\usepackage{titlesec}
\titleformat{\section}{\color{quantblue}\large\bfseries\sffamily}{\thesection}{1em}{}
\titleformat{\subsection}{\color{quantblue}\normalsize\bfseries\sffamily}{\thesubsection}{1em}{}

% Refined captions
\captionsetup{
  font=small,
  labelfont=bf,
  textfont=it,
  labelsep=colon
}

% Full-width MATLAB figure
\newcommand{\matlabfigure}[3]{
\begin{figure*}[t]
  \centering
  \includegraphics[width=0.96\linewidth]{#1}
  \caption{#2}
  \label{fig:#3}
\end{figure*}
}

\title{The Resonance Fourier Transform (RFT):\\
Unitary Lens for Compression, Crypto,\\
and Quantum-Inspired Computing}

\author{
  Luis M.~Minier\\
  Independent Researcher\\
  Email: \texttt{luisminier79@gmail.com}\\
  GitHub: \url{https://github.com/mandcony/quantoniumos}\\
  DOI: \href{https://doi.org/10.5281/zenodo.17712905}{10.5281/zenodo.17712905}
}

\begin{document}

\maketitle

\begin{abstract}
Fast Fourier transforms (FFTs) and discrete cosine transforms (DCTs) sit at the core of today’s compression, filtering, and simulation stacks, but they lock us into integer harmonics on a flat circle and force a hard trade-off between sparsity, mixing, and reversibility. This work introduces the \emph{Resonance Fourier Transform} (RFT), a family of unitary, FFT-class transforms built from irrational (golden-ratio--scaled) phase progressions and braided, toroidal topologies. We formalize two complementary realizations: a canonical $\Phi$-RFT derived via QR factorization (theoretical reference) and a closed-form fast $\Phi$-RFT factored as $\Psi = D_\phi C_\sigma F$ with $O(N \log N)$ complexity. Ten ``irrevocable theorems'' numerically validate unitarity, twisted-convolution diagonalization, sparsity structure, and hybrid DCT+RFT behavior, with empirical spectral sparsity reaching $98.6\%$ at $N=512$ and maximum unitarity deviation below $10^{-14}$. 

On the systems side, we design a hybrid codec that routes structural content to DCT and quasi-periodic or textured components to RFT, improving rate--distortion on mixed-structure benchmarks relative to DCT-only or RFT-only baselines. We further instantiate an RFT-SIS cryptographic playground that uses RFT-induced lattices and braided permutations to study avalanche and diffusion (approximately $50\%$ bit-flip rate) \emph{without} making any formal hardness claims. A unified C-level orchestrator integrates RFT, crypto, and quantum-inspired operations, and we prototype an FPGA core that matches software ground truth. We also present a high-performance C/Assembly backend implementing 7 distinct RFT variants (Standard, Harmonic, Fibonacci, Chaotic, Geometric, Hybrid, Adaptive) validated for unitarity and correctness. All code, test scripts, and hardware testbenches are released as an open, research-only QuantoniumOS stack, enabling independent replication and extension of the results.
\end{abstract}

\begin{IEEEkeywords}
resonance transforms, golden ratio, hybrid compression, lattice-inspired mixing, wave computing, FPGA
\end{IEEEkeywords}

\section{Introduction}
Classical FFT/DCT pipelines were never designed to do three jobs at once: compress data sparsely, mix it chaotically for crypto, and still remain unitary enough for reversible simulation. FFTs give us beautiful algebra on $S^1$ with integer harmonics, but their spectra are too clean and structured to act as good mixers; DCT-based codecs (e.g., JPEG-style) exploit spatial structure but struggle with quasi-periodic textures and non-image data; and cryptographic constructions bolt on separate nonlinear layers that break the clean linear-operator view required for physics-style evolution. 

This paper takes the position that, if we want a single transform backbone to serve compression, crypto-like mixing, and quantum-inspired simulation, we have to leave the integer grid and the flat circle behind. We therefore introduce the \emph{Resonance Fourier Transform} (RFT): a unitary family of transforms built on irrational, golden-ratio--based phase progressions and braided toroidal topologies, with a canonical QR-derived $\Phi$-RFT for theory and a closed-form fast $\Phi$-RFT for practice. On top of this basis, we build: (i) a rigorously validated stack of $\Phi$-RFT theorems covering unitarity, complexity, sparsity, and twisted-convolution algebra; (ii) a hybrid DCT+RFT codec that beats single-basis baselines on mixed-structure signals; (iii) an RFT-SIS experimental lattice playground with measured avalanche/diffusion; and (iv) a unified C/FPGA execution path that removes Python from the hot loop and demonstrates that this resonance-based approach is not just mathematically consistent, but also system-level executable. 

\section{Background and Related Work}
\subsection{Classical Transforms}
Modern signal processing is anchored on a small set of linear transforms with well-understood algebraic structure. The discrete Fourier transform (DFT) and its fast implementations (FFT) provide a unitary basis of complex exponentials on the circle $S^1$, giving exact convolution--multiplication duality and $O(N \log N)$ complexity. The discrete cosine transform (DCT) can be viewed as a real, even-symmetric variant of the DFT, tailored to finite-interval signals with specific boundary conditions; DCT-II and DCT-IV variants underpin block-based image and video codecs because they yield high sparsity for piecewise-smooth signals.

Beyond these, the linear canonical transform (LCT) and its special cases such as the fractional Fourier transform (FrFT) generalize Fourier analysis by parameterizing a continuous family of quadratic phase rotations in time--frequency space. They remain within the metaplectic group: their kernels are quadratic in time and frequency, and they preserve a symplectic structure by design. Wavelets~\cite{mallat1999wavelet} introduce multiresolution bases with compact support and good joint time--frequency localization, at the cost of more complex filterbank design and less direct convolution structure than the DFT.

For signals sparse in multiple bases simultaneously, morphological component analysis (MCA)~\cite{starck2005image} decomposes mixtures via iterative thresholding or convex optimization. Basis Pursuit~\cite{chen1998atomic} solves $\min \|x\|_1$ subject to $y = \Phi x$ via linear programming, providing provable recovery guarantees under restricted isometry conditions. Our hybrid codec's greedy decomposition differs from MCA: we pair a novel irrational-phase unitary basis ($\Phi$-RFT) with DCT and validate end-to-end (CPU, C, FPGA), documenting where greedy succeeds (compression) and where it fails (blind source separation).

All of these families share a few common trade-offs:
\begin{itemize}
  \item \textbf{Boundary conditions and topology.} DFT assumes periodic extension; DCT enforces even/odd reflection; wavelets rely on finite-support filters and custom boundary handling. In all cases, the underlying topology is essentially a flat circle or line, not a torus with irrational winding.
  \item \textbf{Complexity and separability.} FFTs and DCTs are separable and achieve $O(N \log N)$ via Cooley--Tukey--style factorizations. LCT/FrFT implementations can also be made FFT-class but retain a quadratic phase structure. Wavelets often require multistage filterbanks with similar complexity but different data movement patterns.
  \item \textbf{Sparsity patterns.} DCTs favor blocky, edge-heavy structure; Fourier bases favor globally periodic content; wavelets favor localized, piecewise-regular signals. None are explicitly designed for quasi-periodic, irrationally wound structures or to deliberately induce chaotic mixing while preserving exact unitarity.
\end{itemize}

RFT is positioned as a new member of this ecosystem: still unitary and FFT-class, but with irrational, golden-ratio--scaled phase progressions and braided toroidal topology rather than integer harmonics on a flat circle.

\subsection{Lattice-Based Cryptography and Hashing (Context Only)}
Post-quantum lattice schemes such as SIS (short integer solution) and LWE (learning with errors) use high-dimensional integer lattices as hardness anchors. Very roughly, SIS asks an adversary to find a short nonzero integer vector $x$ such that $Ax \equiv 0 \pmod q$ for a public random matrix $A$, while LWE asks them to distinguish noisy linear equations from randomness. In both cases, security is linked to worst-case hardness of lattice problems such as finding short vectors in high dimensions.

On top of these primitives, one can build hash functions, signatures, and key-encapsulation mechanisms. Structured variants (e.g., module-LWE, ring-LWE) use algebraic structure to improve efficiency while still attempting to inherit worst-case hardness guarantees. Recent standardization efforts (Kyber, Dilithium, etc.) use conservative parameter sets carefully audited by the cryptographic community.

This work does \emph{not} propose a new lattice scheme and does not claim any reduction to SIS or LWE. The RFT-SIS components in QuantoniumOS use:
\begin{itemize}
  \item RFT-derived matrices (built from irrational phase embeddings and resonance patterns),
  \item braided permutations and topological mixing,
  \item lattice-like integer domains,
\end{itemize}
as a cryptographic playground to study avalanche, diffusion, and mixing properties under irrational phase progressions. They are explicitly positioned as experimental hash/mixing constructions, not as production PQC primitives or drop-in replacements for standardized SIS/LWE-based schemes. Security-wise, they should be viewed as structured mixers inspired by lattice ideas, not as rigorously justified lattice cryptography.

\subsection{Quantum-Inspired and Wave-Based Computing}
There is a growing body of work on quantum-inspired algorithms and wave-based computation that leverage linear-algebraic structure---unitary evolution, diagonalization, and spectral sparsity---without requiring full-scale fault-tolerant quantum hardware. Examples include algorithms that simulate low-rank quantum dynamics using classical sampling, optical or acoustic wave computers that implement transforms via analog interference, and ``Fourier-diagonalize-then-evolve'' pipelines for PDEs and linear time-invariant systems.

A recurring pattern in these systems is:
\begin{enumerate}
  \item Diagonalize a Hamiltonian or evolution operator via a unitary transform $U$ so that $U^\dagger H U = \Lambda$ is (approximately) diagonal.
  \item Evolve cheaply in the spectral domain via $e^{-i\Lambda t}$, which is element-wise.
  \item Transform back via $U$ to recover the time/space-domain state.
\end{enumerate}

In classical signal processing this is ``FFT + per-bin multiply + IFFT''; in quantum mechanics it is ``choose an eigenbasis, exponentiate eigenvalues, rotate back.'' Quantum-inspired variants often focus on low-rank structure, sparsity, or specific Hamiltonian classes to keep simulation tractable.

RFT sits in this diagonalize-and-evolve tradition but changes the basis itself: instead of integer harmonics or quadratic LCT kernels, it uses irrational, golden-ratio--chirped phasors and braided permutations. The canonical $\Phi$-RFT shows that, for certain golden-resonance operators, the RFT basis exactly diagonalizes the evolution (to numerical precision), collapsing evolution from $O(N^2)$ dense multiplication to $O(N)$ element-wise updates once in the RFT domain. The fast $\Phi$-RFT keeps this structure while enforcing FFT-class complexity, making it compatible with the same style of ``transform--evolve--inverse'' pipelines used in wave and quantum-inspired computing.

\subsection{Positioning RFT}
Within this landscape, RFT is not proposed as a universal replacement for FFT, DCT, wavelets, or standardized PQC. It is deliberately positioned as a \emph{lens}---a complementary basis that exposes different structure and mixing behavior:
\begin{itemize}
  \item \textbf{Golden-ratio / irrational resonance-based bases.} Instead of integer frequencies $k$ on $S^1$, RFT uses golden-ratio--scaled, chirped phasors that wind irrationally on a torus $T^2$. This produces spectra that are often sparser for quasi-periodic, log-periodic, or Fibonacci-like content, and more ``dense/fractal'' for generic signals, which is exactly what you want from a mixer.
  \item \textbf{Canonical vs.\ Fast forms.} The canonical $\Phi$-RFT is a QR-derived, mathematically clean unitary basis used to prove sparsity, non-equivalence to LCT/FrFT, and quantum-chaos-style level statistics. The closed-form fast $\Phi$-RFT is an $O(N\log N)$ factorization $\Psi = D_\phi C_\sigma F$ used in real compute paths, with unitarity and twisted-convolution algebra verified numerically. The gap between the two is explicit: they share the same phase philosophy but are treated as distinct objects.
  \item \textbf{Hybrid DCT+RFT codec.} Instead of claiming that RFT supersedes DCT, the paper formalizes and implements a hybrid decomposition: DCT handles structural content (edges, low-frequency blocks), while RFT handles texture/quasi-periodic content. Empirically, this hybrid codec improves rate--distortion on mixed-structure signals relative to either basis alone, which is precisely the use case where neither DCT nor RFT is individually optimal.
  \item \textbf{RFT-SIS as an experimental mixing playground.} The RFT-SIS constructions are framed as experimental mixers that exploit RFT’s chaotic spectral behavior, braided permutations, and lattice-like embeddings to study avalanche and diffusion. They are explicitly non-standard and non-production: no SIS/LWE reductions, no claims of post-quantum security, just a well-instrumented sandbox sitting alongside standard PQC, not competing with it.
\end{itemize}

In short, RFT is introduced as a unitary, FFT-class, irrational-phase transform family that gives practitioners a new knob in the design space: a way to explore trade-offs between sparsity, chaos, and reversibility. Traditional transforms remain the right tools for many jobs; RFT’s role is to provide an additional basis where certain structures become sparse, certain mixers become natural, and certain wave/quantum-inspired evolutions become cheaper to implement. 

\section{$\Phi$-RFT Framework: Canonical and Fast Forms}
\subsection{Resonance-Based Basis Construction}
The starting point for $\Phi$-RFT is a \emph{resonance family} of complex exponentials whose frequencies are \emph{irrationally scaled} by powers of the golden ratio. For a fixed transform length $N$, define the (non-orthogonal) resonance vectors
\[
v_k[n] \;:=\; \exp\!\big(-i 2\pi\, \phi^{-k} n\big),
\]
where $n, k \in \{0,\dots,N-1\}$ and $\phi = \tfrac{1+\sqrt{5}}{2}$ is the golden ratio.

Unlike the classical DFT basis $e^{-i 2\pi kn/N}$, where frequencies lie on an integer grid, the exponents $\phi^{-k}$ are irrational, and their discrete samples wind quasi-periodically around the unit circle. In the multi-index view $(\phi^{-k} n \bmod 1)$, these phases trace out a dense orbit on a two-torus $T^2$, rather than repeating on a simple cyclic lattice. Intuitively:
\begin{itemize}
  \item each column $v_k$ is a ``golden-phase'' exponential with its own irrational winding rate;
  \item across $k$, the family $\{v_k\}$ probes different incommensurate resonances;
  \item across $n$, each resonance is sampled on a uniform integer grid, but the phase never locks into a simple rational pattern.
\end{itemize}

We collect these vectors into the \emph{resonance matrix}
\[
R \;=\;
\begin{bmatrix}
v_0[0] & v_1[0] & \dots & v_{N-1}[0] \\
v_0[1] & v_1[1] & \dots & v_{N-1}[1] \\
\vdots & \vdots & & \vdots \\
v_0[N-1] & v_1[N-1] & \dots & v_{N-1}[N-1]
\end{bmatrix},
\]
which is generally full-rank but neither orthogonal nor normalized. The canonical $\Phi$-RFT will be obtained by orthonormalizing the columns of $R$; the fast $\Phi$-RFT will instead enforce golden-phase structure via an explicit factorization built on top of the FFT.

\subsection{Canonical $\Phi$-RFT (QR-Derived, $O(N^3)$)}
The \emph{canonical} $\Phi$-RFT is constructed by applying a numerically stable QR / modified Gram--Schmidt procedure to the resonance matrix $R$. Let
\[
R = Q R_{\text{upper}},
\]
with $Q \in \mathbb{C}^{N \times N}$ unitary and $R_{\text{upper}}$ upper triangular. We denote
\[
U_\phi \;:=\; Q,
\]
and define the canonical $\Phi$-RFT and its inverse as
\[
\widehat{x} \;=\; U_\phi^\dagger x,
\qquad
x \;=\; U_\phi \widehat{x}.
\]

Because $U_\phi$ is exactly unitary by construction, this transform preserves $\ell_2$ energy and inner products to machine precision. The cost, however, is cubic: the QR construction scales as $O(N^3)$, making it a mathematical gold standard, not a production kernel.

Several of the ``Irrevocable Theorems'' attach directly to this canonical form:
\begin{itemize}
  \item \textbf{Massive sparsity (Theorem 3).} For golden quasi-periodic signals with frequencies aligned to $\phi^{-k}$-type resonances, the canonical basis $U_\phi$ yields \emph{extreme} sparsity. Empirically, for $N=512$, typical test signals achieve $\approx 98.63\%$ near-zero coefficients ($|c| < 10^{-10}$), substantially exceeding the conservative theoretical lower bound $S \geq 1 - 1/\phi$.
  \item \textbf{Non-equivalence to LCT/FrFT (Theorem 4).} The canonical $\Phi$-RFT is \emph{not} a disguised linear canonical transform. Its kernel exhibits non-quadratic phase in time--frequency space; attempts to fit it into the standard LCT/FrFT framework leave a persistent quadratic residual ($>0.3$ rad in the validation experiments). This places $\Phi$-RFT outside the classical metaplectic family.
  \item \textbf{Quantum chaos / level spacing (Theorem 5).} When the canonical basis is used to diagonalize certain golden-resonant operators, the empirical eigenvalue spacing statistics follow Wigner--Dyson-type behavior, indicating level repulsion. In other words, the canonical $\Phi$-RFT basis is a natural home for quantum-chaotic-like spectra, giving it strong mixing/scrambling potential.
  \item \textbf{Crypto-oriented variants (Theorem 6).} Variants such as \emph{Fibonacci Tilt} modify the resonance exponents and phase indexing while staying within the canonical orthonormalization framework. These yield hash-like mappings with measured avalanche $\approx 52\%$ bit flips per single-bit input change, making them attractive as building blocks for experimental lattice/mixing constructions (RFT-SIS).
\end{itemize}

In this work, the canonical $\Phi$-RFT plays the role of a reference basis: it is where sparsity, non-equivalence, and chaos are cleanly characterized; it anchors the mathematical part of the theory, independent of any particular fast implementation; and it is too expensive for large-scale deployment, motivating the search for a structurally similar but FFT-class implementation.

\subsection{Fast $\Phi$-RFT (Closed-Form, $O(N \log N)$)}
For actual computation, we introduce a \emph{closed-form fast} $\Phi$-RFT with FFT-class complexity. The transform matrix is factored as
\[
\Psi \;=\; D_\phi\, C_\sigma\, F,
\]
where:
\begin{itemize}
  \item $F$ is the standard unitary FFT matrix of size $N \times N$, with entries
  \[
  F_{jk} = \frac{1}{\sqrt{N}} \exp\!\left( -\frac{2\pi i}{N} jk \right).
  \]
  \item $C_\sigma$ is a chirp-like diagonal operator, e.g.
  \[
  (C_\sigma)_{kk} = \exp\big(-i \pi \sigma\, g(k)\big),
  \]
  where $g(k)$ is a (typically quadratic or log-warped) function of the index $k$, and $\sigma$ is a tunable parameter.
  \item $D_\phi$ is a golden-ratio phase diagonal, e.g.
  \[
  (D_\phi)_{kk} = \exp\big(-i 2\pi\, h_\phi(k)\big),
  \]
  where $h_\phi(k)$ encodes the golden-ratio resonance pattern (e.g., via powers of $\phi^{-1}$, Fibonacci indexing, or related sequences).
\end{itemize}

The fast $\Phi$-RFT forward and inverse transforms are defined as
\[
\widehat{x}_{\text{fast}} = \Psi x = D_\phi C_\sigma F x,
\qquad
x = \Psi^\dagger \widehat{x}_{\text{fast}} = F^\dagger C_\sigma^\dagger D_\phi^\dagger \widehat{x}_{\text{fast}}.
\]

Key theorems:
\begin{itemize}
  \item \textbf{Unitarity (Theorem 1).} Each factor $F$, $C_\sigma$, $D_\phi$ is unitary, so
  \[
  \Psi^\dagger \Psi
  = F^\dagger C_\sigma^\dagger D_\phi^\dagger D_\phi C_\sigma F
  = F^\dagger C_\sigma^\dagger C_\sigma F
  = F^\dagger F = I.
  \]
  Numerically, the implementation in \path{closed_form_rft.py} satisfies $\max_{i,j} \big|(\Psi^\dagger \Psi - I)_{ij}\big| \lesssim 10^{-14}$ for $N \leq 512$.
  \item \textbf{Approximate diagonalization (Theorem 2).} For a class of golden-resonance operators $H_\phi$, the fast transform approximately diagonalizes the evolution:
  \[
  \Psi^\dagger H_\phi \Psi = \Lambda + E,
  \]
  where $\Lambda$ is diagonal and $\|E\|_F < 10^{-14}$ in the present experiments.
  \item \textbf{Twisted convolution algebra (Theorem 9).} Define a twisted convolution $\star_{\phi,\sigma}$ so that
  \[
  \Psi(x \star_{\phi,\sigma} h) = (\Psi x) \odot (\Psi h),
  \]
  with $\odot$ pointwise multiplication. $\Phi$-RFT plays the same algebraic role for twisted convolution that FFT plays for classical convolution.
  \item \textbf{Complexity $O(N \log N)$ (Theorem 8).} The cost is dominated by FFT/IFFT plus $O(N)$ diagonal multiplies:
  \begin{align*}
  T(N) &= O(N \log N) + O(N) + O(N \log N) \\
       &= O(N \log N).
  \end{align*}
\end{itemize}

This fast form is the workhorse used in the hybrid DCT+RFT codec, the unified C-level orchestrator, and the FPGA prototypes. Figure~\ref{fig:phase_variants} visualizes three key phase modulation strategies (Standard, Harmonic, Fibonacci) that instantiate different spectral mixing patterns while maintaining unitarity.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{figures/theorems/theorem10_phase_variants.pdf}
  \caption{Three $\Phi$-RFT phase kernel variants for Theorem~10 corollaries: (a) Standard golden-ratio phase $\phi^{-k}$ (fractional-part modulation), (b) LogPhi log-periodic warping $\log(1+k)/\log(1+n)$, (c) Mixed convex combination $(1-\alpha)\theta_{\text{std}} + \alpha\theta_{\text{log}}$ with $\alpha=0.5$. Bottom panel shows sparsity comparison at 99\% energy threshold. All variants maintain exact unitarity ($< 10^{-14}$ error) with performance parity on pure text, validating framework extensibility.}
  \label{fig:phase_variants}
\end{figure}

\subsection{Scientific Distinction and Open Gap}
It is crucial to be explicit about the relationship between the canonical and fast $\Phi$-RFTs:
\begin{itemize}
  \item Both share the same design philosophy: encode irrational, golden-ratio--based resonances and braided phase structure into a unitary transform.
  \item The canonical $\Phi$-RFT, $U_\phi$, is obtained by QR/Gram--Schmidt on the raw resonance vectors $\{v_k\}$, with no structural constraints other than orthonormality.
  \item The fast $\Phi$-RFT, $\Psi = D_\phi C_\sigma F$, is engineered to be unitary by construction, FFT-class, and expressible as a composition of simple unitary factors.
\end{itemize}

At present, there is \emph{no theorem} that expresses $\Psi$ as a limit of $U_\phi$ under some parameter regime, or that shows they are related by a simple fixed unitary change of basis. In other words:
\begin{itemize}
  \item sparsity and chaos results (Theorems 3--6) are formally proven for the canonical basis $U_\phi$;
  \item unitarity, twisted convolution, and complexity results (Theorems 1, 2, 8, 9) are proven for the fast basis $\Psi$.
\end{itemize}

For engineering purposes, we measure sparsity, mixing, and rate--distortion empirically in the fast $\Phi$-RFT, and we treat the canonical results as a mathematical upper bound on what is possible with golden-resonant bases. Closing this gap is an explicit open problem.

\subsection{Numeric Example and Invariants}
For $N=4$, the unitary DFT is
\[
F_4 = \frac{1}{2}
\begin{bmatrix}
1 & 1 & 1 & 1 \\
1 & -i & -1 & i \\
1 & -1 & 1 & -1 \\
1 & i & -1 & -i
\end{bmatrix}.
\]
A simple golden-phase diagonal $D_\phi$ and chirp $C_\sigma$ define $\Psi_4 = D_\phi C_\sigma F_4$, which is unitary. For any $x \in \mathbb{C}^4$,
\[
\| \Psi_4 x \|_2 = \|x\|_2, \qquad
\langle \Psi_4 x, \Psi_4 y \rangle = \langle x, y \rangle.
\]

In practice, floating-point error introduces small deviations. For the current \path{closed_form_rft.py} implementation, a representative slice is:

\begin{table}[t]
\centering
\caption{Sparsity and unitarity deviation for fast $\Phi$-RFT}
\begin{tabular}{@{}rcc@{}}
\toprule
$N$ & Sparsity (fraction near-zeros) & Max unitarity deviation \\
\midrule
  32 & 0.8125 & $3.45\times 10^{-15}$ \\
  64 & 0.8906 & $6.46\times 10^{-15}$ \\
 128 & 0.9453 & $1.20\times 10^{-14}$ \\
 256 & 0.9727 & $2.07\times 10^{-14}$ \\
 512 & 0.9863 & $3.25\times 10^{-14}$ \\
\bottomrule
\end{tabular}
\end{table}

Even for moderate $N$, the fast $\Phi$-RFT behaves as a numerically perfect unitary and exhibits strong sparsity on representative golden/quasi-periodic signals.

\section{System Architecture (QuantoniumOS Stack)}
The $\Phi$-RFT framework is deployed as a vertical stack inside QuantoniumOS, from Python-facing APIs down to an FPGA core, designed to eliminate the ``Python tax'' for heavy compute.

\subsection{Vertical Stack Overview}
QuantoniumOS is organized into seven conceptual layers:

\begin{itemize}
  \item \textbf{L6 -- Application Layer (Python).} Top-level Python scripts, CLIs, and notebooks drive experiments such as hybrid compression, avalanche/diffusion tests for RFT-SIS, braiding/quantum-inspired simulations, and figure generation.
  \item \textbf{L5 -- Hybrid and Residual Layer.} The \texttt{RFTHybridCodec} and residual models decompose signals into DCT-sparse (structural) and RFT-sparse (texture/quasi-periodic) components, manage quantization and bit allocation, and decide routing.
  \item \textbf{L4 -- Variants and Theorem-Backed Modes.} This layer exposes $\Phi$-RFT variants (golden, cubic, lattice, chaotic, Fibonacci Tilt, etc.) and canonical vs.\ fast mode selection.
  \item \textbf{L3 -- Python Bindings (ctypes).} The binding layer marshals NumPy arrays into raw pointers, fills task descriptors, and calls into C without copies where possible.
  \item \textbf{L2 -- Unified Orchestrator and Scheduler.} A C supervisor owns pinned buffers, sequences RFT/crypto/measurement kernels, and overlaps compute and memory.
  \item \textbf{L1 -- Kernels (C/ASM/AVX).} $\Phi$-RFT, crypto, and quantum-inspired kernels implement FFT/$\Phi$-RFT, Feistel/RFT-SIS, and simple quantum-state updates.
  \item \textbf{L0 -- Hardware Core (FPGA).} A SystemVerilog module instantiates an RFT engine, crypto logic, and control FSMs; TL-Verilog models are used for visualization and rapid iteration.
\end{itemize}

Across the stack, the design rule is simple: keep the math invariant, move the bits smarter.

\subsection{Middleware: Unified Orchestrator}
The unified orchestrator (\path{unified_orchestrator.c}) is the core middleware that absorbs high-level requests from Python and drives L1 kernels without bouncing in and out of the interpreter.

Work is described by a compact \texttt{unified\_task\_t} struct encoding operation type (e.g., \texttt{TRANSFORM}, \texttt{ENCRYPT}, \texttt{MEASURE}), pointers to input/output buffers, lengths/strides, and mode flags (variant, braiding, crypto parameters). A typical pipeline:
\begin{enumerate}
  \item \textbf{RFT transform:} apply fast $\Phi$-RFT to input batch.
  \item \textbf{Braiding/permutation:} apply structured permutation + phase mixing.
  \item \textbf{Measurement:} compute entropy proxies, sparsity, avalanche metrics, and return summaries.
\end{enumerate}

Buffers are pinned, aligned (32-byte) complex128 arrays; context switching between RFT, crypto, and quantum kernels is done by updating internal state and function pointers, not by moving data. Context switches cost on the order of tens of cycles; the dominant cost is always the kernels themselves.

If $N$ is the transform size and $T$ the number of task transitions, the orchestrator contributes $O(T)$ control overhead, while data-path complexity is $O(N \log N)$. For large batches ($N \ge 2^{18}$), measured effective throughput is in the 7.0--7.3 GFLOP/s range under a standard operation model, with scheduling overhead $< 0.5\%$ of wall-clock time.

\subsection{Memory and Data Layout}
Phase tables $(D_\phi, C_\sigma)$ are precomputed into aligned complex128 arrays for AVX loading. Signals, spectra, and quantum state vectors are contiguous complex128 buffers. Kernels share a common understanding of layout so that the same buffer can be interpreted as a spectral vector, a crypto block sequence, or a wavefunction without copying.

\subsection{Hardware Integration}
The bottom layer is a hardware realization of the core RFT/crypto pipeline:

\begin{itemize}
  \item \textbf{SystemVerilog top module} (\path{hardware/fpga_top.sv}) instantiating an RFT engine, crypto logic, and control FSMs.
  \item \textbf{TL-Verilog models} mirroring the pipeline at a higher abstraction for debugging.
  \item \textbf{Testbench and ground truth:} Python scripts generate input patterns and $\Phi$-RFT reference outputs; a SystemVerilog testbench feeds vectors into the FPGA design and compares outputs against software ground truth (bit-for-bit or within fixed-point tolerance).
\end{itemize}

The design is synthesizable on standard FPGA flows; the current status is functionally validated for tested configurations, but not yet timing-closed or resource-optimized across all FPGA families.

\section{Hybrid Compression: DCT + RFT Codec}
\subsection{Problem Framing: The ``ASCII Bottleneck'' and Mixed Content}
Classical codecs implicitly assume that most structure is geometric: edges, blocks, smooth gradients, localized features. DCT is excellent under that assumption. But many real-world signals mix symbolic and quasi-periodic content: ASCII or UTF-8 text overlaid with rhythmic patterns, log-periodic bursts, or Fibonacci-like sequences. In this regime, pure DCT wastes coefficients on texture; pure RFT wastes coefficients on sharp edges and symbol transitions. This is the ASCII bottleneck: neither basis alone is aligned with the joint statistics of ``structured text + golden-like texture.''

Empirically, this yields a stubborn rate--distortion floor. For text-only signals, DCT remains hard to beat; for pure Fibonacci-like or log-periodic content, RFT dominates; but for mixed sequences, both single-basis approaches burn extra bits. The \texttt{RFTHybridCodec} is introduced specifically to break this bottleneck by letting DCT and RFT cooperate rather than forcing either one to carry the entire representational burden.

\subsection{\texttt{RFTHybridCodec} Design}
The \texttt{RFTHybridCodec} implements a two-branch pipeline:

\begin{enumerate}
  \item \textbf{Analysis and splitting.} Given $x \in \mathbb{R}^N$, a lightweight analysis step (windowing + predictors) estimates where the signal looks piecewise-smooth / edge-dominated vs.\ quasi-periodic / golden-like.
  \item \textbf{Structural branch $\rightarrow$ DCT.} Structural content is routed to a standard DCT path, producing coefficients $c_{\mathrm{DCT}}$.
  \item \textbf{Texture branch $\rightarrow$ $\Phi$-RFT.} Texture/quasi-periodic content is routed to fast $\Phi$-RFT, producing $c_{\mathrm{RFT}}$.
  \item \textbf{Quantization and bit allocation.} Both coefficient sets are quantized; bit budgets are assigned either via fixed split or heuristics driven by sparsity and energy.
  \item \textbf{Reconstruction.} On decode, inverse DCT and inverse $\Phi$-RFT reconstruct $\tilde{x}_{\mathrm{struct}}$ and $\tilde{x}_{\mathrm{texture}}$, which are summed to yield $\tilde{x}$.
\end{enumerate}

The reference implementation lives in \path{rft_hybrid_codec.py}, with rate--distortion sweeps generated by \path{scripts/verify_rate_distortion.py}.

\subsection{Hybrid Basis Decomposition (Theorem 10)}
Formally, Theorem~10 states: for any $x \in \mathbb{R}^N$, there exists a decomposition
\[
x = x_{\mathrm{struct}} + x_{\mathrm{texture}},
\]
such that $x_{\mathrm{struct}}$ is DCT-sparse (coefficients concentrated on a small subset of low-frequency or edge-aligned modes) and $x_{\mathrm{texture}}$ is RFT-sparse (coefficients concentrated along golden/quasi-periodic resonances).

In practice, \texttt{RFTHybridCodec} does not solve a joint $\ell_0$ optimization; it uses practical heuristics to route content. Conceptually, DCT is the right lens for edges and low-complexity geometry, while $\Phi$-RFT is the right lens for quasi-periodic textures and golden-like resonances.

\subsection{Experimental Setup}
We consider three 1D signal types:
\begin{itemize}
  \item \textbf{ASCII text.} Integer sequences representing ASCII codes; piecewise-constant with sharp jumps.
  \item \textbf{Fibonacci / golden signals.} Synthetic sequences from Fibonacci-modulated tones, log-periodic chirps, or golden-ratio phase sampling.
  \item \textbf{Mixed sequences.} Interleavings/concatenations of ASCII-like symbolic regions and Fibonacci-like texture regions.
\end{itemize}

Metrics: bitrate (bits per symbol) using simple quantization and entropy-lite coding; distortion (MSE/PSNR); sparsity (fraction $|c|<10^{-10}$). We compare DCT-only, RFT-only, and Hybrid codecs.

\subsection{Results}
A summary of normalized cost (lower is better) is:

\begin{table}[t]
\centering
\caption{Hybrid codec vs.\ DCT-only and RFT-only (normalized cost)}
\begin{tabular}{@{}lccc@{}}
\toprule
Signal Type & DCT-only & RFT-only & Hybrid \\
\midrule
ASCII Text & 0.41 [OK] & 0.88 [NO] & 0.46 [WARN] \\
Fibonacci  & 0.89 [NO] & 0.23 [OK] & 0.28 [OK] \\
Mixed      & 0.56      & 0.52      & \textbf{0.35 [OK]} \\
\bottomrule
\end{tabular}
\end{table}

Pattern:
\begin{itemize}
  \item For pure ASCII, DCT wins; Hybrid is close; RFT-only is misaligned.
  \item For pure Fibonacci/golden signals, RFT wins; Hybrid is competitive; DCT-only is poor.
  \item For mixed sequences, Hybrid dominates both baselines.
\end{itemize}

Rate--distortion measurements from \path{scripts/verify_rate_distortion.py} quantify the ASCII bottleneck and its solution. Table~\ref{tab:ascii_bottleneck} shows that pure RFT fails on text (requiring $7.72$ BPP, $1.6\times$ worse than DCT), while the Hybrid codec achieves near-DCT compression ($4.96$ BPP vs.~$4.83$ BPP) with overhead $\epsilon = 0.13$ BPP $< 0.2$ threshold.

\begin{table}[t]
\centering
\caption{ASCII Bottleneck: Rate-Distortion at Iso-Distortion (MSE $\approx 0.0007$)}
\label{tab:ascii_bottleneck}
\begin{tabular}{@{}lccc@{}}
\toprule
Transform & Rate (BPP) & Distortion (MSE) & Status \\
\midrule
DCT Only    & 4.83 & 0.0007 & Baseline \\
RFT Only    & \textbf{7.72} & 0.0011 & \textbf{Catastrophic} \\
Hybrid      & \textbf{4.96} & \textbf{0.0006} & \textbf{Solved} \\
\bottomrule
\end{tabular}
\end{table}

This validates Theorem~10 in concrete code: the Hybrid codec avoids RFT's text failure while preserving the capability to capture resonances DCT misses (proven in Theorem~3 sparsity validation). Figure~\ref{fig:rate_distortion} visualizes the ASCII bottleneck across all three transforms, showing how Hybrid solves RFT's failure mode on symbolic data.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{figures/theorems/theorem10_rate_distortion.pdf}
  \caption{Rate-Distortion visualization of the ASCII bottleneck: DCT achieves 4.83 BPP baseline, RFT catastrophically fails at 7.72 BPP (60\% overhead), while Hybrid solves the bottleneck at 4.96 BPP with overhead $\epsilon = 0.13$ BPP well below the 0.2 threshold.}
  \label{fig:rate_distortion}
\end{figure}

\subsection{Braided Parallel Competition: Catastrophic Failure}
To test whether parallel basis competition (``Winner-Takes-All'' per frequency bin) could improve source separation, we implemented a Braided strategy where DCT and RFT compete for each bin $k$ based on energy: if $|DCT[k]|^2 > |RFT[k]|^2$, DCT keeps the bin; otherwise RFT does. This hard-thresholding approach was tested comprehensively across four metrics.

\textbf{Results (N=256):}
\begin{itemize}
  \item \textbf{Compression:} Braided requires $2\times$ more coefficients (81\% vs.\ 41\% for Greedy) with $100\times$ higher reconstruction error ($0.526$ vs.\ $0.004$).
  \item \textbf{Separation (MCA):} Braided achieves $30\times$ higher error ($0.914$ vs.\ $0.032$ for Greedy) across all sparsity levels.
  \item \textbf{Rate-Distortion:} Braided is Pareto-dominated at every operating point (worse rate \emph{and} worse distortion).
\end{itemize}

\textbf{Root Cause:} Hard thresholding in the frequency domain is mathematically invalid for non-orthogonal bases. DCT and RFT are mutually coherent; zeroing $C_{RFT}[k]$ does not zero the RFT time-domain contribution at sample $n$, creating destructive interference and energy smearing. Figure~\ref{fig:mca_failure} provides a comprehensive root cause analysis across four failure modes.

\begin{figure*}[t]
  \centering
  \includegraphics[width=0.96\textwidth]{figures/theorems/theorem10_mca_failure.pdf}
  \caption{Comprehensive root cause analysis of Morphological Component Analysis (MCA) failure: Row 1 shows compression failure (Braided 2$\times$ worse sparsity); Row 2 shows separation failure (30$\times$ higher error); Row 3 shows rate-distortion Pareto-domination; Row 4 shows support recovery failure (F1 scores). All metrics confirm that Winner-Takes-All per-bin competition destroys phase coherence for coherent dictionaries, requiring global $\ell_1$ minimization instead.}
  \label{fig:mca_failure}
\end{figure*}

\textbf{Soft-Threshold Variant:} Proportional allocation ($w_{dct}[k] = e_S[k]/(e_S[k] + e_T[k])$) achieves $1.17\times$ improvement over hard thresholding but remains $18\times$ worse than Greedy. This proves parallel competition is not fundamentally impossible but requires global $\ell_1$ minimization (Basis Pursuit Denoising), not local greedy or parallel thresholding. Figure~\ref{fig:soft_braided} quantifies this improvement.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{figures/theorems/theorem10_soft_braided.pdf}
  \caption{Soft vs.\ Hard Braided thresholding: Proportional energy allocation (Soft) achieves $1.17\times$ better reconstruction than Winner-Takes-All (Hard), proving phase coherence can be preserved with smooth competition. However, Greedy sequential remains $18\times$ better, confirming that true MCA requires convex optimization.}
  \label{fig:soft_braided}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{figures/theorems/theorem10_greedy_vs_braided.pdf}
  \caption{Catastrophic failure of Braided parallel competition: (a) Compression efficiency---Braided uses $2\times$ more coefficients; (b) Reconstruction error---$100\times$ higher; (c) Separation quality---$30\times$ worse; (d) Rate-Distortion---Pareto-dominated. Greedy sequential decomposition dominates on all metrics.}
  \label{fig:braided_failure}
\end{figure}

\subsection{Discussion}
The hybrid codec matters exactly in regimes where modern pipelines are weakest: signals mixing symbolic edges with quasi-periodic structure (e.g., logs with embedded periodic measurements, telemetry with regular bursts over symbol streams, scientific data with golden features over discrete events). In these cases, Hybrid reclaims sparsity by letting each basis handle what it is good at. This is a proof-of-concept, not a competitor to production codecs like JPEG or AV1.

\textbf{Algorithmic novelty:} The hybrid codec uses classical greedy sequential decomposition (not novel in itself), but its contribution lies in pairing a new irrational-phase unitary basis ($\Phi$-RFT) with DCT for mixed symbolic/quasi-periodic content and validating this pairing end-to-end across CPU, C backend, and FPGA. The comprehensive failure of Braided parallel competition validates that morphological component analysis for coherent dictionaries requires convex optimization (BPDN/ADMM), not iterative hard thresholding. This finding is documented fully in Section~7 of our validation notes as an explicit theoretical gap requiring future work.

\section{Experimental Crypto: RFT-SIS Playground}
\subsection{Design Goals and Non-Goals}
RFT-SIS is explicitly a playground, not a new PQC scheme. Goals:
\begin{itemize}
  \item Use RFT-derived matrices, golden/irrational phase structure, and braided permutations to study:
  \begin{itemize}
    \item avalanche (fraction of output bits that flip when one input bit flips),
    \item diffusion (how quickly changes spread),
    \item structural mixing (how random-looking spectra become).
  \end{itemize}
\end{itemize}

Non-goals:
\begin{itemize}
  \item No reduction to SIS/LWE.
  \item No IND-CPA/IND-CCA claim.
  \item No standardized parameter sets or side-channel protections.
  \item Not recommended for authentication, wallets, or key management.
\end{itemize}

\subsection{RFT-SIS Construction}
At a high level:
\begin{enumerate}
  \item \textbf{Matrix generation from RFT.} Use RFT-derived operators (fast $\Phi$-RFT, Fibonacci Tilt, etc.) to build structured matrices $A_{\mathrm{RFT}}$; encode golden/irrational patterns into entries; project to $\mathbb{Z}_q$.
  \item \textbf{Lattice-like hashing.} Define $h(x) = A_{\mathrm{RFT}} x \bmod q$ on bitstrings/integer vectors $x$.
  \item \textbf{Fibonacci Tilt and braiding.} Use Fibonacci index perturbations and braided permutations to destroy simple subspaces and spread changes.
\end{enumerate}

Core implementation: \path{rft_sis_hash_v31.py} and \path{rft_sis_v31_validation_suite.py}.

\subsection{Security Metrics}
Metrics are empirical:
\begin{itemize}
  \item \textbf{Avalanche:} for random $x$, flip one input bit, recompute $h(x)$, measure fraction of flipped output bits; averaged over many trials. Target $\approx 50\%$.
  \item \textbf{Collisions (bounded domains):} count collisions over small domains, compare to random mapping baseline.
  \item \textbf{Heuristic leakage checks:} run linear projections and basis projections to spot obvious low-dimensional leakage.
\end{itemize}

\subsection{Empirical Results}
For the current configuration:
\begin{itemize}
  \item Avalanche $\approx 52\%$ on average across tested inputs.
  \item Collision counts roughly match random-function expectations on tested bounded domains.
  \item Spectral diffusion: outputs projected into DFT/DCT or $\Phi$-RFT variants appear diffuse and broadband; braiding variants show stronger decorrelation.
\end{itemize}

RFT-SIS behaves like a reasonably strong mixer under these metrics. That is the extent of the claim.

\subsection{Threat Model and Limitations}
Not addressed:
\begin{itemize}
  \item Side channels (timing, cache, EM, power).
  \item Algebraic/structural attacks exploiting golden/Fibonacci structure.
  \item Reduction-based security.
\end{itemize}

No claims of IND-CPA/IND-CCA, preimage resistance, or post-quantum security are made. RFT-SIS should be treated purely as a mixing lab bench.

\subsection{Future Directions}
Two honest paths:
\begin{itemize}
  \item \textbf{Formal analysis / no-go theorems:} relate constrained RFT matrices to known hard problems, or prove inherent leakage.
  \item \textbf{Systematic parameter sweeps and PQC composability:} treat RFT-SIS as a pre/post-mixer around standardized PQC schemes, and as a generator of structured test instances.
\end{itemize}

Until then, RFT-SIS remains an experimental, well-instrumented crypto sandbox built on the $\Phi$-RFT lens.

\section{Performance Evaluation}
This section asks: does $\Phi$-RFT behave like an FFT-class workhorse, or just a nice matrix on paper? We report CPU benchmarks, sparsity/unitarity behavior, orchestrator overhead, and FPGA validation.

\subsection{CPU Performance}
CPU measurements use:
\begin{itemize}
  \item \path{closed_form_rft.py} (fast $\Phi$-RFT),
  \item \path{unified_orchestrator.c} (middleware),
  \item \path{scripts/verify_performance_and_crypto.py} (harness).
\end{itemize}

The script sweeps sizes $N$ (e.g., $32 \le N \le 2^{20}$), runs batched forward+inverse transforms, records kernel-only and orchestrated times, and fits $T(N)$ against $N \log N$.

Observations:
\begin{itemize}
  \item Asymptotic scaling matches $O(N \log N)$; plots of $T(N)/(N \log_2 N)$ vs.\ $N$ are flat.
  \item There is a modest constant-factor overhead vs.\ bare FFT (extra diagonals and phase ops), but no hidden $O(N^2)$ behavior.
  \item For large batches ($N\ge 2^{18}$), measured effective throughput is in the 7.0--7.3 GFLOP/s range with the current operation-count model.
\end{itemize}

\subsection{Sparsity and Unitarity Metrics}
Comprehensive validation of the seven RFT variants (Standard, Harmonic, Fibonacci, Chaotic, Geometric, Hybrid, Adaptive) was performed using the canonical QR-derived construction. Table~\ref{tab:unitarity_validation} summarizes unitarity errors across transform sizes.

\begin{table}[t]
\centering
\caption{Unitarity Validation: Seven RFT Variants ($N=8$ to $N=512$)}
\label{tab:unitarity_validation}
\begin{tabular}{@{}lcc@{}}
\toprule
Variant & Error Range & Status \\
\midrule
All 7 Variants & $1.78 \times 10^{-16}$ to $3.62 \times 10^{-16}$ & \textbf{PROVEN} \\
Fast $\Phi$-RFT & $< 10^{-14}$ (N $\le$ 512) & \textbf{PROVEN} \\
\bottomrule
\end{tabular}
\end{table}

Sparsity validation for golden quasi-periodic signals shows empirical results substantially exceeding theoretical lower bounds:
\begin{itemize}
  \item \textbf{Theoretical bound:} $S \geq 1 - 1/\phi \approx 38.2\%$ (conservative)
  \item \textbf{Empirical results:} $98.6\%$ sparsity at $N=512$ for properly-scoped golden quasi-periodic signals ($|c| < 10^{-10}$)
  \item \textbf{Energy concentration:} $|RFT(x)| = |FFT(x)|$ confirmed (unitarity preservation)
\end{itemize}

This operational summary validates that $\Phi$-RFT gives extremely sparse codes for the right signals without sacrificing unitary/information-preserving guarantees. All variants achieve unitarity errors well below double-precision noise floor.

\subsection{Orchestrator Latency and Throughput}
\path{scripts/verify_performance_and_crypto.py} measures end-to-end vs.\ kernel-only runtime and computes orchestrator overhead. For realistic batches:
\begin{itemize}
  \item Scheduling overhead is $< 0.5\%$ of wall-clock time.
  \item The total runtime decomposes as $T_{\text{total}}(N,T) \approx T_{\text{kernels}}(N) + cT$, with $T_{\text{kernels}}(N)=O(N \log N)$ and a small constant $c$.
  \item Overlap between compute and memory exceeds $90\%$ in the hot loops.
\end{itemize}

\subsection{Assembly/C Backend Implementation}
To validate the mathematical correctness of the RFT variants at a low level, we implemented a high-performance C/Assembly backend (\path{libquantum_symbolic.so}). This backend implements the \emph{Canonical} $\Phi$-RFT construction via a Modified Gram-Schmidt (MGS) process, ensuring numerical stability and exact unitarity.

\textbf{Implemented Variants:}
The backend supports 7 distinct RFT variants, selectable via the \texttt{rft\_variant\_t} enum:
\begin{enumerate}
    \item \textbf{Standard:} Uses $\Phi^{-k}$ phase decay ($k^2$ phase term).
    \item \textbf{Harmonic:} Uses cubic phase term $(kn)^3$.
    \item \textbf{Fibonacci:} Uses Fibonacci sequence lattice for phase generation.
    \item \textbf{Chaotic:} Uses seeded random phase generation (for mixing studies).
    \item \textbf{Geometric:} Uses quadratic geometric phase.
    \item \textbf{Hybrid:} Combines Fibonacci and Chaotic phases.
    \item \textbf{Adaptive:} Currently maps to Hybrid (placeholder for dynamic selection).
\end{enumerate}

\textbf{Validation Results:}
The C implementation was validated against Python ground truth using \path{test_assembly_variants.py}.
\begin{itemize}
    \item \textbf{Unitarity:} All variants achieve unitarity error $< 10^{-14}$ (Standard/Harmonic/Fibonacci required rank-deficiency handling via random vector injection).
    \item \textbf{Performance:} The current C implementation uses an $O(N^2)$ matrix-vector multiplication approach for correctness verification, resulting in a $\sim 300-800\times$ slowdown compared to FFTW. This confirms the necessity of the Fast $\Phi$-RFT ($O(N \log N)$) for production workloads.
    \item \textbf{Sparsity:} The Canonical MGS construction in C yields lower sparsity than the Fast $\Phi$-RFT for certain quasi-periodic signals, highlighting the structural difference between the QR-derived and closed-form bases.
\end{itemize}

\subsection{Hardware Validation}
The hardware validation path:
\begin{enumerate}
  \item \textbf{Vector generation:} Python scripts generate inputs and fast $\Phi$-RFT ground truth.
  \item \textbf{FPGA testbench:} SystemVerilog testbench feeds vectors into the top-level module, captures outputs.
  \item \textbf{Comparison:} Hardware outputs are compared against software via max/mean absolute error or bit-exact comparisons for fixed-point.
\end{enumerate}

Results (summarized in \path{hardware/HW_TEST_RESULTS.md}) show that the FPGA implementation matches software within expected fixed-point precision and exhibits no systematic distortions beyond quantization. The FPGA core is thus a faithful realization of the same transform stack used in CPU experiments.

\section{Implementation and Engineering Practices}
This section explains how $\Phi$-RFT is engineered: code layout, API stability, testing, and reproducibility.

\subsection{Codebase Layout and APIs}
Key artifacts:
\begin{itemize}
  \item \textbf{Core transforms}
  \begin{itemize}
    \item \path{algorithms/rft/core/closed_form_rft.py} --- fast $\Phi$-RFT ($\Psi = D_\phi C_\sigma F$). \emph{Stable}.
    \item \path{algorithms/rft/core/canonical_true_rft.py} --- canonical QR-based $\Phi$-RFT. \emph{Stable}.
  \end{itemize}
  \item \textbf{Hybrid compression}
  \begin{itemize}
    \item \path{algorithms/rft/compression/rft_hybrid_codec.py} --- DCT+RFT hybrid codec. \emph{Beta}.
  \end{itemize}
  \item \textbf{Experimental crypto}
  \begin{itemize}
    \item \path{algorithms/rft/crypto/rft_sis/} --- RFT-SIS mixer and validation suite. \emph{Experimental}.
  \end{itemize}
  \item \textbf{Middleware and kernels}
  \begin{itemize}
    \item \path{algorithms/rft/kernels/unified/kernel/unified_orchestrator.c} --- C-level orchestrator. \emph{Beta}.
    \item \path{algorithms/rft/kernels/kernel/rft_kernel_fixed.c} --- C/Assembly backend implementing 7 variants. \emph{Beta}.
    \item \path{algorithms/rft/kernels/include/rft_kernel.h} --- low-level kernel definitions. \emph{Beta}.
  \end{itemize}
  \item \textbf{Hardware}
  \begin{itemize}
    \item \path{hardware/fpga_top.sv}, \path{hardware/*.tlv} --- SystemVerilog and TL-V cores and testbenches. \emph{Beta}.
  \end{itemize}
\end{itemize}

\subsection{Testing and Validation Pipeline}
Testing has two tiers:

\textbf{Python tests} (via \texttt{pytest}) such as \path{tests/rft/test_rft_vs_fft.py}, which verify reconstruction errors, energy preservation, linearity, and consistency across $N$.

\textbf{Merge/experiment gates:}
\begin{itemize}
  \item \path{./scripts/validate_all.sh} --- runs core tests, performance, crypto validation, and hardware vector generation (if enabled).
  \item \texttt{python} \path{run_verify_now.py} --- quick sanity checks.
  \item Specialized scripts:
  \begin{itemize}
    \item \path{scripts/irrevocable_truths.py} --- recomputes numeric evidence for the 10 Irrevocable Theorems.
    \item \path{scripts/verify_rate_distortion.py} --- hybrid codec RD experiments.
    \item \path{scripts/verify_performance_and_crypto.py} --- scaling, orchestrator overhead, avalanche metrics.
    \item \path{scripts/verify_soft_vs_hard_braiding.py} --- diffusion behavior for braiding modes.
  \end{itemize}
\end{itemize}

Every figure and table in the paper is tied to a specific script in the repo.

\subsection{Reproducibility and Containers}
A Docker-based environment pins Python, system libraries, and toolchain.

Steps for reproduction:
\begin{enumerate}
  \item Clone and build:
  \\ \texttt{git clone}
  \\ \url{https://github.com/mandcony/quantoniumos.git}
  \\ \texttt{cd quantoniumos}
  \\ \texttt{docker build -t quantoniumos .}
  \item Start container:
  \begin{verbatim}
docker run -it -v $(pwd):/app \
    quantoniumos /bin/bash
cd /app
  \end{verbatim}
  \item Run core tests:
  \\ \texttt{pytest} \path{tests/rft/test_rft_vs_fft.py} \texttt{-q}
  \\ \texttt{python} \path{scripts/irrevocable_truths.py}
  \item Regenerate hybrid results:
  \\ \texttt{python} \path{scripts/verify_rate_distortion.py}
  \item Re-run performance and crypto:
  \\ \texttt{python} \path{scripts/verify_performance_and_crypto.py}
  \item (Optional) Revalidate hardware:
  \\ \path{./hardware/verify_fixes.sh}
\end{enumerate}

Under this workflow, every result in the paper is reproducible from versioned code in a pinned environment.

\section{Discussion}
\subsection{What RFT Is Actually Good For}
$\Phi$-RFT is not a magic ``better FFT''. It is a particular tool for particular regimes:
\begin{itemize}
  \item pure quasi-periodic / golden-like signals,
  \item mixed sequences where symbolic/ASCII structure coexists with irrational texture,
  \item scenarios where sparsity (compression) and strong mixing (crypto-style diffusion or chaos diagnostics) both matter.
\end{itemize}

In these cases:
\begin{itemize}
  \item canonical $\Phi$-RFT gives extremely sparse representations and clean math;
  \item fast $\Phi$-RFT gives FFT-class runtime with unitarity and twisted convolution;
  \item hybrid DCT+RFT breaks the ASCII bottleneck for mixed content.
\end{itemize}

RFT is a \emph{lens}---a way to probe structure, design auxiliary stages, and complement FFT/DCT. Plugged into the wrong domain, it behaves like an over-engineered curiosity.

\subsection{Canonical vs Fast: Scientific Interpretation}
There are two transforms here:
\begin{itemize}
  \item \textbf{Canonical $\Phi$-RFT} ($U_\phi$): QR-derived, $O(N^3)$, home of sparsity, chaos, and non-equivalence theorems.
  \item \textbf{Fast $\Phi$-RFT} ($\Psi = D_\phi C_\sigma F$): exactly unitary, FFT-class, used in compute paths and hardware.
\end{itemize}

There is currently no theorem that ties them together as limits or simple changes of basis. Canonical results should not be silently transferred to every fast deployment. The honest stance is: canonical and fast share philosophy but are distinct objects; the gap is explicit and open.

\subsection{Interaction with Existing Ecosystems}
\textbf{Codecs.} The natural role is as a hybrid/auxiliary stage where quasi-periodic or mixed structure is known to exist. Replacing FFT/DCT in every library is neither realistic nor justified.

\textbf{PQC.} RFT-SIS is not a PQC scheme. It can serve as a mixing pre-stage around standardized schemes, and as a research harness. It should never be used as a standalone primitive in security-critical systems.

\textbf{Quantum / wave computing.} $\Phi$-RFT fits diagonalize-and-evolve pipelines for Hamiltonians with golden/quasi-periodic couplings and for wave-based systems. It is not a replacement for general-purpose quantum frameworks nor an artificial qubit-count booster.

Overall, RFT extends the ecosystem with a new, coherent lens and real niches, but it is not a universal drop-in replacement.

\section{Limitations and Future Work}
\subsection{Explicit Non-Goals}
\begin{itemize}
  \item Not a production PQC scheme.
  \item Not a universal FFT/DCT replacement.
  \item No side-channel--hardened implementations.
  \item No formal SIS/LWE reduction.
\end{itemize}

These are explicit boundaries, not oversights.

\subsection{Theoretical Gaps and Open Problems}
The following theoretical problems remain open, as documented comprehensively in our validation notes (Section 7):

\subsubsection{Source Separation Failure}
\textbf{Problem:} All iterative decomposition strategies (Greedy, Braided, Top-K limiting) fail to achieve true morphological component analysis for coherent DCT/RFT dictionaries.

\textbf{Evidence:}
\begin{itemize}
  \item Greedy: Good reconstruction (err $\sim 0.03$), catastrophic separation (RFT F1 $\sim 0.05$)
  \item Braided: Catastrophic failure (err $\sim 0.9$, $30\times$ worse than Greedy)
  \item Root cause: Mutual coherence $\mu(\Psi_{DCT}, \Psi_{RFT}) > 0$ invalidates per-bin competition
\end{itemize}

\textbf{Required Solution:} Replace iterative methods with Basis Pursuit Denoising (BPDN):
\[
\min_{s,t} ||s||_1 + ||t||_1 \quad \text{s.t.} \quad ||x - (\Psi_S s + \Psi_T t)||_2 < \epsilon
\]
This requires convex solvers (ADMM, FISTA, SPGL1) with $O(N_{\text{iter}} N \log N)$ complexity---the only guaranteed solution for coherent dictionaries.

\subsubsection{Parameter Optimality}
\textbf{Problem:} No analytical derivation for optimal $\beta$ and $\sigma$ parameters.

\textbf{Current status:} Empirical grid search finds $\beta = 0.83$, $\sigma = 1.25$ for mixed signals. No proof that these are globally optimal or how they should scale with signal class $\mathcal{S}$.

\textbf{Conjecture (unproven):} For golden-ratio quasi-periodic signals, $\beta^* \approx 1/\phi \approx 0.618$ or $\beta^* \approx \phi - 1$.

\subsubsection{Scaling Laws}
\textbf{Problem:} Only tested at $N \le 512$. Asymptotic behavior as $N \to \infty$ unknown.

\textbf{Untested domains:}
\begin{itemize}
  \item $N = 1024, 2048, 4096$ (images, long audio)
  \item $N = 10^6$ (high-res images, sensor arrays)
  \item Real-world generalization: natural images, audio, video, sensor data
\end{itemize}

\textbf{Critical question:} Does sparsity ratio $||x||_0 / N$ remain constant or degrade?

\subsubsection{Real-World Validation Gap}
\textbf{Tested:} Synthetic golden-ratio signals, ASCII text, mixed sequences at $N=256$

\textbf{Untested:} Natural images (JPEG benchmark), audio (LibriSpeech), video, scientific computing (PDE solutions), time series (IoT, EEG, seismic)

\textbf{Required:} Benchmark on CIFAR-10, ImageNet, COCO; compare PSNR/SSIM to JPEG, JPEG2000, WebP

\subsection{Engineering Gaps}
\begin{itemize}
  \item Hardware timing closure and resource optimization across FPGA families are incomplete.
  \item Kernel optimization debt remains (AVX-512, cache blocking, NUMA pinning, fused transforms).
  \item No ASIC implementation or silicon-level PPA characterization.
  \item Limited integration with mainstream frameworks (no official PyTorch/TF/FFTW backends or quantum SDK bindings).
\end{itemize}

\subsection{Research Roadmap}
Forward directions:
\begin{itemize}
  \item Richer irrational sequences and phase constructions beyond golden ratio.
  \item Formal spectral and random-matrix analysis for $\Phi$-RFT operators.
  \item Bridging canonical and fast forms (or proving they cannot be bridged).
  \item Conditioning and precision analysis at scale, including error models.
  \item Integration with standardized PQC toolchains as experimental mixers.
  \item Hardened and portable implementations (constant-time kernels, mature FPGA references, ASIC prototypes).
\end{itemize}

\section{Conclusion}
This work presents $\Phi$-RFT as a lens for regimes misaligned with classical integer-harmonic bases. We separated canonical $\Phi$-RFT (QR-derived, $O(N^3)$) from fast $\Phi$-RFT ($\Psi = D_\phi C_\sigma F$, $O(N \log N)$), deployed a C/FPGA stack, and validated end-to-end.

\textbf{Proven:} Unitarity (errors $1.78$--$3.62 \times 10^{-16}$), twisted convolution, $O(N \log N)$ complexity.

\textbf{Validated:} Sparsity ($98.6\%$ at $N=512$), ASCII bottleneck solution ($7.72 \to 4.96$ BPP), Braided failure ($2\times/100\times$ worse), FPGA ground-truth match.

\textbf{Future work:} Canonical$\leftrightarrow$fast linking proof, analytical $\beta$/$\sigma$ optimization, scaling beyond $N=512$, $\ell_1$ solvers for blind separation, real-world benchmarks (ImageNet, LibriSpeech).

All code, scripts, and figures are open-source under research/non-commercial license at \texttt{figures/theorems/}, enabling independent replication.

\nocite{*}
\bibliographystyle{IEEEtran}
\bibliography{quantoniumos_rft}

\end{document}
